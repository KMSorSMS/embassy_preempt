#![feature(prelude_import)]
#![no_std]
#![no_main]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![feature(allocator_api)]
#![feature(alloc_layout_extra)]
#![feature(slice_ptr_get)]
#![feature(sync_unsafe_cell)]
#![feature(alloc_error_handler)]
#![feature(const_mut_refs)]
#![feature(never_type)]
#![warn(missing_docs)]
//! the mod of uC/OS-II kernel and the interface that uC/OS-II kernel provides
#[prelude_import]
use core::prelude::rust_2021::*;
#[macro_use]
extern crate core;
extern crate compiler_builtins as _;
/// This mod MUST go first, so that the others see its macros.
use cortex_m::{interrupt, register::primask};
use critical_section::{set_impl, Impl, RawRestoreState};
use defmt_rtt as _;
extern crate alloc;
/// the mod of uC/OS-II kernel
pub mod os_core {
    use core::sync::atomic::Ordering;
    use defmt::info;
    use os_cpu::*;
    use crate::ucosii::OS_TASK_IDLE_PRIO;
    use crate::executor::GlobalSyncExecutor;
    use crate::heap::stack_allocator::init_stack_allocator;
    use crate::os_task::OSTaskCreate;
    use crate::os_time::OSTimerInit;
    use crate::port::*;
    #[cfg(feature = "OS_TASK_REG_TBL_SIZE")]
    use crate::ucosii::OSTaskRegNextAvailID;
    use crate::ucosii::{
        OSCtxSwCtr, OSIdleCtr, OSIntNesting, OSLockNesting, OSRunning, OSTaskCtr, OSTime,
    };
    #[allow(unused)]
    const OSUnMapTbl: [INT8U; 256] = [
        0,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        5,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        6,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        5,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        7,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        5,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        6,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        5,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        4,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
        3,
        0,
        1,
        0,
        2,
        0,
        1,
        0,
    ];
    /// This function is used to initialize the internals of uC/OS-II and MUST be called
    /// prior to creating any uC/OS-II object and, prior to calling OSStart().
    pub fn OSInit() {
        OSInitHookBegin();
        OS_InitTaskIdle();
        init_stack_allocator();
        OSTimerInit();
    }
    /// This function is used to notify uC/OS-II that you are about to service
    /// an interrupt service routine (ISR).  This allows uC/OS-II to keep track
    /// of interrupt nesting and thus only perform rescheduling at the last nested ISR.
    pub fn OSIntEnter() {}
    /// This function is used to notify uC/OS-II that you have completed servicing
    /// an ISR.  When the last nested ISR has completed, uC/OS-II will call the
    /// scheduler to determine whether a new, high-priority task, is ready to run.
    pub fn OSIntExit() {}
    /// This function is used to start the multitasking process which lets
    /// uC/OS-II manages the task that you have created.  Before you can call
    /// OSStart(), you MUST have called OSInit() and you MUST have created at
    /// least one task.
    pub fn OSStart() -> ! {
        use crate::heap::stack_allocator::INTERRUPT_STACK;
        extern "Rust" {
            fn set_int_change_2_psp(int_ptr: *mut u8);
        }
        OSRunning.store(true, Ordering::Release);
        let int_stk = INTERRUPT_STACK.exclusive_access();
        let int_ptr = int_stk.STK_REF.as_ptr() as *mut u8;
        drop(int_stk);
        unsafe {
            set_int_change_2_psp(int_ptr);
            critical_section::with(|_| {
                GlobalSyncExecutor.as_ref().unwrap().set_highrdy()
            });
            GlobalSyncExecutor.as_ref().unwrap().poll();
        }
    }
    /// This function is used to signal to uC/OS-II the occurrence of a 'system tick'
    /// (also known as a 'clock tick').  This function should be called by the ticker
    /// ISR but, can also be called by a high priority task.
    /// fin this to use Timer
    /// This function is used to return the version number of uC/OS-II.
    /// The returned value corresponds to uC/OS-II's version number multiplied by 10000.
    /// In other words, version 2.01.00 would be returned as 20100.
    pub fn OSVersion() -> INT16U {
        return 0;
    }
    #[allow(unused)]
    fn OS_InitEventList() {}
    #[allow(unused)]
    fn OS_InitMisc() {
        #[cfg(feature = "OS_TIME_GET_SET_EN")] OSTime.store(0, Ordering::Release);
        OSIntNesting.store(0, Ordering::Release);
        OSLockNesting.store(0, Ordering::Release);
        OSTaskCtr.store(0, Ordering::Release);
        OSRunning.store(false, Ordering::Release);
        OSCtxSwCtr.store(0, Ordering::Release);
        OSIdleCtr.store(0, Ordering::Release);
        #[cfg(feature = "OS_TASK_REG_TBL_SIZE")]
        OSTaskRegNextAvailID.store(0, Ordering::Release);
    }
    #[allow(unused)]
    fn OS_InitRdyList() {}
    fn OS_InitTaskIdle() {
        extern "Rust" {
            fn run_idle();
        }
        let idle_fn = |_args: *mut ()| -> ! {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::os_core".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"idle task\",\"disambiguator\":\"8769731706866933001\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"idle task\",\"disambiguator\":\"8769731706866933001\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            loop {}
        };
        OSTaskCreate(idle_fn, 0 as *mut (), 0 as *mut usize, OS_TASK_IDLE_PRIO);
    }
    #[allow(unused)]
    fn OS_InitTCBList() {}
    /// This function is called by other uC/OS-II services to clear a contiguous block of RAM.
    pub fn OS_MemClr() {}
    /// This function is called by other uC/OS-II services to copy a block of
    /// memory from one location to another.
    pub fn OS_MemCopy() {}
    /// This function is called by other uC/OS-II services to determine whether a new, high
    /// priority task has been made ready to run.  This function is invoked by TASK level code
    /// and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
    pub fn OS_Sched() {}
    #[allow(unused)]
    fn OS_SchedNew() {}
    /// This function is called by other uC/OS-II services to determine the size of an ASCII string (excluding the NUL character)
    pub fn OS_StrLen(_psrc: &str) -> INT8U {
        return 0;
    }
    #[allow(unused)]
    fn OS_TaskIdle() {}
}
/// the mod of flag of uC/OS-II kernel
pub mod os_flag {}
/// the mod of mailbox of uC/OS-II kernel
pub mod os_mbox {}
/// the mod of memory management of uC/OS-II kernel
pub mod os_mem {}
/// the mod of mutex of uC/OS-II kernel
pub mod os_mutex {}
/// the mod of queue of uC/OS-II kernel
pub mod os_q {
    /// init the message queue
    pub fn OS_QInit() {}
}
/// the stk allocator
pub mod arena {
    //! the allocator of the stack this crate only will be used by executor
    use core::alloc::Layout;
    use core::cell::{Cell, UnsafeCell};
    use core::mem::MaybeUninit;
    use core::ptr::null_mut;
    use critical_section::{CriticalSection, Mutex};
    use defmt::info;
    use crate::cfg::OS_ARENA_SIZE;
    /// Every TCB(here, we store TaskStorage) will be stored here.
    pub static ARENA: Arena<{ OS_ARENA_SIZE }> = Arena::new();
    /// The stack allocator defination of uC/OS-II.
    pub struct Arena<const N: usize> {
        buf: UnsafeCell<MaybeUninit<[u8; N]>>,
        ptr: Mutex<Cell<*mut u8>>,
    }
    unsafe impl<const N: usize> Sync for Arena<N> {}
    unsafe impl<const N: usize> Send for Arena<N> {}
    impl<const N: usize> Arena<N> {
        const fn new() -> Self {
            Self {
                buf: UnsafeCell::new(MaybeUninit::uninit()),
                ptr: Mutex::new(Cell::new(null_mut())),
            }
        }
        /// alloc the stack memory for the task(TCB) list.
        pub fn alloc<T>(
            &'static self,
            cs: CriticalSection,
        ) -> &'static mut MaybeUninit<T> {
            let layout = Layout::new::<T>();
            let start = self.buf.get().cast::<u8>();
            let end = unsafe { start.add(N) };
            let mut ptr = self.ptr.borrow(cs).get();
            if ptr.is_null() {
                ptr = self.buf.get().cast::<u8>();
            }
            let bytes_left = (end as usize) - (ptr as usize);
            let align_offset = (ptr as usize).next_multiple_of(layout.align())
                - (ptr as usize);
            if align_offset + layout.size() > bytes_left {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "embassy-executor: task arena is full. You must increase the arena size, see the documentation for details: https://docs.embassy.dev/embassy-executor/",
                        ),
                    );
                };
            }
            let res = unsafe { ptr.add(align_offset) };
            let ptr = unsafe { ptr.add(align_offset + layout.size()) };
            self.ptr.borrow(cs).set(ptr);
            unsafe { &mut *(res as *mut MaybeUninit<T>) }
        }
    }
}
/// need to import port here
pub mod cfg {
    use crate::port::*;
    use crate::ucosii::OS_PRIO;
    /// the const val define the lowest prio
    pub const OS_LOWEST_PRIO: OS_PRIO = 63;
    /// Size of task variables array (#of INT32U entries)
    pub const OS_TASK_REG_TBL_SIZE: USIZE = 1;
    /// Max. number of memory partitions
    pub const OS_MAX_MEM_PART: USIZE = 5;
    /// Max. number of tasks in your application, MUST be >= 2
    pub const OS_MAX_TASKS: USIZE = 20;
    /// This const val is used to config the size of ARENA.
    /// You can set it refer to the number of tasks in your application(OS_MAX_TASKS) and the number of system tasks(OS_N_SYS_TASKS).
    pub const OS_ARENA_SIZE: USIZE = 1024;
    /// output frequency of the Timer. frequency of the Systick(run on Timer)
    pub const TICK_HZ: INT64U = 100_000;
    /// input frequency of the Timer, you should config it yourself(set the Hardware)
    pub const APB_HZ: INT64U = 84000000;
}
/// the async scheduler(executor) of rust uC
pub mod executor {
    //! Raw task storage and pool.
    #[path = "state_atomics_arm.rs"]
    pub mod state {
        //! ARM-specific atomic state operations.
        use core::arch::asm;
        use core::sync::atomic::{compiler_fence, AtomicBool, AtomicU32, Ordering};
        pub(crate) const STATE_SPAWNED: u32 = 1 << 0;
        pub(crate) const STATE_RUN_QUEUED: u32 = 1 << 8;
        #[repr(C, align(4))]
        pub(crate) struct State {
            /// Task is spawned (has a future)
            spawned: AtomicBool,
            /// Task is in the executor run queue
            run_queued: AtomicBool,
            /// Task is in the executor timer queue
            timer_queued: AtomicBool,
            pad: AtomicBool,
        }
        impl State {
            pub const fn new() -> State {
                Self {
                    spawned: AtomicBool::new(false),
                    run_queued: AtomicBool::new(false),
                    timer_queued: AtomicBool::new(false),
                    pad: AtomicBool::new(false),
                }
            }
            fn as_u32(&self) -> &AtomicU32 {
                unsafe { &*(self as *const _ as *const AtomicU32) }
            }
            /// If task is idle, mark it as spawned + run_queued and return true.
            #[inline(always)]
            pub fn spawn(&self) -> bool {
                compiler_fence(Ordering::Release);
                let r = self
                    .as_u32()
                    .compare_exchange(
                        0,
                        STATE_SPAWNED | STATE_RUN_QUEUED,
                        Ordering::Relaxed,
                        Ordering::Relaxed,
                    )
                    .is_ok();
                compiler_fence(Ordering::Acquire);
                r
            }
            /// Unmark the task as spawned.
            #[inline(always)]
            pub fn despawn(&self) {
                compiler_fence(Ordering::Release);
                self.spawned.store(false, Ordering::Relaxed);
            }
            /// Mark the task as run-queued if it's spawned and isn't already run-queued. Return true on success.
            #[inline(always)]
            pub fn run_enqueue(&self) -> bool {
                unsafe {
                    loop {
                        let state: u32;
                        asm!(
                            "ldrex {0}, [{1}]", out(reg) state, in (reg) self,
                            options(nostack)
                        );
                        if (state & STATE_RUN_QUEUED != 0)
                            || (state & STATE_SPAWNED == 0)
                        {
                            asm!("clrex", options(nomem, nostack));
                            return false;
                        }
                        let outcome: usize;
                        let new_state = state | STATE_RUN_QUEUED;
                        asm!(
                            "strex {0}, {1}, [{2}]", out(reg) outcome, in (reg)
                            new_state, in (reg) self, options(nostack)
                        );
                        if outcome == 0 {
                            return true;
                        }
                    }
                }
            }
        }
    }
    /// The executor for the uC/OS-II RTOS.
    pub mod timer_queue {
        use defmt::info;
        use super::OS_TCB_REF;
        use crate::util::SyncUnsafeCell;
        pub(crate) struct TimerQueue {
            head: SyncUnsafeCell<Option<OS_TCB_REF>>,
            pub(crate) set_time: SyncUnsafeCell<u64>,
        }
        impl TimerQueue {
            pub const fn new() -> Self {
                Self {
                    head: SyncUnsafeCell::new(None),
                    set_time: SyncUnsafeCell::new(u64::MAX),
                }
            }
            /// Insert a task into the timer queue.(sorted by `expires_at`,the header is the nearest task)
            /// return the next expiration time.
            pub(crate) unsafe fn update(&self, p: OS_TCB_REF) -> u64 {
                let p_expires_at = &p.expires_at;
                if *p_expires_at.get_unmut() == u64::MAX {
                    return u64::MAX;
                }
                let head = self.head.get_unmut();
                let mut cur = head;
                let mut prev: &Option<OS_TCB_REF> = &None;
                while let Some(cur_ref) = cur {
                    let cur_expires_at = &cur_ref.expires_at;
                    if cur_expires_at > p_expires_at {
                        break;
                    }
                    prev = cur;
                    cur = cur_ref.OSTimerNext.get_unmut();
                }
                p.OSTimerNext.set(*cur);
                p.OSTimerPrev.set(*prev);
                if let Some(cur_ref) = cur {
                    cur_ref.OSTimerPrev.set(Some(p));
                }
                if let Some(prev_ref) = prev {
                    prev_ref.OSTimerNext.set(Some(p));
                } else {
                    self.head.set(Some(p));
                }
                let mut cur = head;
                while let Some(cur_ref) = cur {
                    let cur_expires_at = &cur_ref.expires_at;
                    match (&(cur_expires_at.get_unmut())) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor::timer_queue"
                                            .as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"---the cur_expires_at is {}---\",\"disambiguator\":\"9277408569810185534\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"---the cur_expires_at is {}---\",\"disambiguator\":\"9277408569810185534\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    cur = cur_ref.OSTimerNext.get_unmut();
                }
                return *head.as_ref().unwrap().expires_at.get_unmut();
            }
            pub(crate) unsafe fn next_expiration(&self) -> u64 {
                let head = self.head.get_unmut();
                if let Some(head_ref) = head {
                    *head_ref.expires_at.get_unmut()
                } else {
                    u64::MAX
                }
            }
            pub(crate) unsafe fn dequeue_expired(
                &self,
                now: u64,
                on_task: impl Fn(OS_TCB_REF),
            ) {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor::timer_queue"
                                        .as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"dequeue expired\",\"disambiguator\":\"14438847631119912584\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"dequeue expired\",\"disambiguator\":\"14438847631119912584\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let head = self.head.get_unmut();
                let mut cur = head;
                while let Some(cur_ref) = cur {
                    let cur_expires_at = &cur_ref.expires_at;
                    match (&(cur_expires_at.get_unmut())) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor::timer_queue"
                                            .as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the cur_expires_at is {}\",\"disambiguator\":\"9725537178037172669\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the cur_expires_at is {}\",\"disambiguator\":\"9725537178037172669\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    if *cur_expires_at.get_unmut() > now {
                        break;
                    }
                    on_task(*cur_ref);
                    cur_ref.expires_at.set(u64::MAX);
                    let next = cur_ref.OSTimerNext.get_unmut();
                    if let Some(next_ref) = next {
                        next_ref.OSTimerPrev.set(*cur_ref.OSTimerPrev.get_unmut());
                    }
                    if let Some(prev_ref) = cur_ref.OSTimerPrev.get_unmut() {
                        prev_ref.OSTimerNext.set(*next);
                    } else {
                        self.head.set(*next);
                    }
                    cur = next;
                }
            }
        }
    }
    pub mod waker {
        //! Waker implementation for uC/OS-II.
        use core::mem;
        use core::task::{RawWaker, RawWakerVTable, Waker};
        use super::{wake_task, OS_TCB, OS_TCB_REF};
        static VTABLE: RawWakerVTable = RawWakerVTable::new(clone, wake, wake, drop);
        unsafe fn clone(p: *const ()) -> RawWaker {
            RawWaker::new(p, &VTABLE)
        }
        unsafe fn wake(p: *const ()) {
            wake_task(OS_TCB_REF::from_ptr(p as *const OS_TCB))
        }
        unsafe fn drop(_: *const ()) {}
        pub(crate) unsafe fn from_task(p: OS_TCB_REF) -> Waker {
            Waker::from_raw(RawWaker::new(p.as_ptr() as _, &VTABLE))
        }
        /// Get a task pointer from a waker.
        ///
        /// This can be used as an optimization in wait queues to store task pointers
        /// (1 word) instead of full Wakers (2 words). This saves a bit of RAM and helps
        /// avoid dynamic dispatch.
        ///
        /// You can use the returned task pointer to wake the task with [`wake_task`](super::wake_task).
        ///
        /// # Panics
        ///
        /// Panics if the waker is not created by the Embassy executor.
        pub fn task_from_waker(waker: &Waker) -> OS_TCB_REF {
            let hack: &WakerHack = unsafe { mem::transmute(waker) };
            if hack.vtable != &VTABLE {
                {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Found waker not created by the Embassy executor. `embassy_time::Timer` only works with the Embassy executor.",
                        ),
                    );
                }
            }
            unsafe { OS_TCB_REF::from_ptr(hack.data as *const OS_TCB) }
        }
        struct WakerHack {
            data: *const (),
            vtable: &'static RawWakerVTable,
        }
    }
    use alloc::string::String;
    use core::alloc::Layout;
    use core::future::Future;
    use core::mem;
    use core::ops::{Deref, DerefMut};
    use core::pin::Pin;
    use core::ptr::NonNull;
    use core::task::{Context, Poll};
    use defmt::info;
    use lazy_static::lazy_static;
    use state::State;
    use time_driver::{AlarmHandle, Driver, RTC_DRIVER};
    pub use self::waker::task_from_waker;
    use crate::arena::ARENA;
    use crate::cfg::*;
    use crate::heap::stack_allocator::{alloc_stack, OS_STK_REF, TASK_STACK_SIZE};
    use crate::port::*;
    use crate::ucosii::*;
    use crate::util::{SyncUnsafeCell, UninitCell};
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    /// the global executor will be initialized at os init
    pub(crate) struct GlobalSyncExecutor {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub(crate) static GlobalSyncExecutor: GlobalSyncExecutor = GlobalSyncExecutor {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for GlobalSyncExecutor {
        type Target = Option<SyncExecutor>;
        fn deref(&self) -> &Option<SyncExecutor> {
            #[inline(always)]
            fn __static_ref_initialize() -> Option<SyncExecutor> {
                Some(SyncExecutor::new(Pender(0 as *mut ())))
            }
            #[inline(always)]
            fn __stability() -> &'static Option<SyncExecutor> {
                static LAZY: ::lazy_static::lazy::Lazy<Option<SyncExecutor>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for GlobalSyncExecutor {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    /// the TCB of the task. It contains the task's info
    #[allow(unused)]
    pub struct OS_TCB {
        OSTCBStkPtr: Option<OS_STK_REF>,
        #[cfg(feature = "OS_TASK_CREATE_EXT_EN")]
        OSTCBExtInfo: OS_TCB_EXT,
        OSTimerNext: SyncUnsafeCell<Option<OS_TCB_REF>>,
        OSTimerPrev: SyncUnsafeCell<Option<OS_TCB_REF>>,
        OS_POLL_FN: SyncUnsafeCell<Option<unsafe fn(OS_TCB_REF)>>,
        OSTCBDly: INT32U,
        OSTCBStat: State,
        OSTCBPrio: INT8U,
        OSTCBX: INT8U,
        OSTCBY: INT8U,
        OSTCBBitX: INT8U,
        OSTCBBitY: INT8U,
        OSTCBCyclesTot: INT32U,
        OSTCBCyclesStart: INT32U,
        OSTCBStkBase: Option<OS_STK_REF>,
        OSTCBStkUsed: INT32U,
        #[cfg(feature = "OS_TASK_REG_TBL_SIZE")]
        OSTCBRegTbl: [INT32U; OS_TASK_REG_TBL_SIZE],
        pub(crate) expires_at: SyncUnsafeCell<u64>,
    }
    #[cfg(feature = "OS_TASK_CREATE_EXT_EN")]
    #[allow(unused)]
    pub(crate) struct OS_TCB_EXT {
        OSTCBExtPtr: PTR,
        OSTCBStkBottom: Option<OS_STK_REF>,
        OSTCBStkSize: INT32U,
        OSTCBOpt: INT16U,
        OSTCBId: INT16U,
    }
    /// the storage of the task. It contains the task's TCB and the future
    #[allow(unused)]
    pub struct OS_TASK_STORAGE<F: Future + 'static> {
        task_tcb: OS_TCB,
        future: UninitCell<F>,
    }
    /// the ref of the TCB. In other crate only it can be used to access the TCB
    #[allow(unused)]
    pub struct OS_TCB_REF {
        /// the pointer to the TCB
        pub ptr: Option<NonNull<OS_TCB>>,
    }
    #[automatically_derived]
    #[allow(unused)]
    impl ::core::clone::Clone for OS_TCB_REF {
        #[inline]
        fn clone(&self) -> OS_TCB_REF {
            let _: ::core::clone::AssertParamIsClone<Option<NonNull<OS_TCB>>>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(unused)]
    impl ::core::marker::Copy for OS_TCB_REF {}
    /// An uninitialized [`OS_TASK_STORAGE`].
    #[allow(unused)]
    pub struct AvailableTask<F: Future + 'static> {
        task: &'static OS_TASK_STORAGE<F>,
    }
    impl OS_TCB {
        fn restore_context_from_stk(&mut self) {
            extern "Rust" {
                fn restore_thread_task();
            }
            if self.OSTCBStkPtr.is_none() {
                return;
            }
            unsafe { restore_thread_task() };
        }
        /// get the stk ptr of tcb, and set the tcb's stk ptr to None
        pub fn take_stk(&mut self) -> OS_STK_REF {
            self.OSTCBStkPtr.take().unwrap()
        }
        /// set the stk ptr of tcb
        pub fn set_stk(&mut self, stk: OS_STK_REF) {
            self.OSTCBStkPtr = Some(stk);
        }
        /// by noah: *TEST*, judge whether the task stk is none
        pub fn is_stk_none(&self) -> bool {
            self.OSTCBStkPtr.is_none()
        }
    }
    impl OS_TCB_EXT {
        fn init(&mut self, pext: *mut (), opt: INT16U, id: INT16U) {
            self.OSTCBExtPtr = pext;
            self.OSTCBOpt = opt;
            self.OSTCBId = id;
        }
    }
    impl<F: Future + 'static> OS_TASK_STORAGE<F> {
        /// create a new OS_TASK_STORAGE
        const fn new() -> Self {
            Self {
                task_tcb: OS_TCB {
                    OSTCBStkPtr: None,
                    #[cfg(feature = "OS_TASK_CREATE_EXT_EN")]
                    OSTCBExtInfo: OS_TCB_EXT {
                        OSTCBExtPtr: 0 as PTR,
                        OSTCBStkBottom: None,
                        OSTCBStkSize: 0,
                        OSTCBOpt: 0,
                        OSTCBId: 0,
                    },
                    OSTimerNext: SyncUnsafeCell::new(None),
                    OSTimerPrev: SyncUnsafeCell::new(None),
                    OS_POLL_FN: SyncUnsafeCell::new(None),
                    OSTCBDly: 0,
                    OSTCBStat: State::new(),
                    OSTCBPrio: 0,
                    OSTCBX: 0,
                    OSTCBY: 0,
                    OSTCBBitX: 0,
                    OSTCBBitY: 0,
                    OSTCBCyclesTot: 0,
                    OSTCBCyclesStart: 0,
                    OSTCBStkBase: None,
                    OSTCBStkUsed: 0,
                    #[cfg(feature = "OS_TASK_REG_TBL_SIZE")]
                    OSTCBRegTbl: [0; OS_TASK_REG_TBL_SIZE],
                    expires_at: SyncUnsafeCell::new(u64::MAX),
                },
                future: UninitCell::uninit(),
            }
        }
        /// init the storage of the task, just like the spawn in Embassy
        pub fn init(
            prio: INT8U,
            id: INT16U,
            pext: *mut (),
            opt: INT16U,
            _name: String,
            future_func: impl FnOnce() -> F,
        ) -> OS_ERR_STATE {
            let task_ref = OS_TASK_STORAGE::<F>::claim();
            let this: &mut OS_TASK_STORAGE<F>;
            unsafe {
                this = &mut *(task_ref.as_ptr() as *mut OS_TASK_STORAGE<F>);
                this.task_tcb.OS_POLL_FN.set(Some(OS_TASK_STORAGE::<F>::poll));
                this.future.write_in_place(future_func);
            }
            this.task_tcb.OSTCBPrio = prio;
            this.task_tcb.OSTCBY = prio >> 3;
            this.task_tcb.OSTCBX = prio & 0x07;
            this.task_tcb.OSTCBBitY = 1 << this.task_tcb.OSTCBY;
            this.task_tcb.OSTCBBitX = 1 << this.task_tcb.OSTCBX;
            if !this.task_tcb.OSTCBStat.spawn() {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("task with prio {0} spawn failed", prio),
                    );
                };
            }
            #[cfg(feature = "OS_TASK_CREATE_EXT_EN")]
            this.task_tcb.OSTCBExtInfo.init(pext, opt, id);
            critical_section::with(|_cs| {
                unsafe { GlobalSyncExecutor.as_ref().unwrap().enqueue(task_ref) };
            });
            if OS_TASK_REG_TBL_SIZE > 0 {
                for i in 0..OS_TASK_REG_TBL_SIZE {
                    this.task_tcb.OSTCBRegTbl[i] = 0;
                }
            }
            return OS_ERR_STATE::OS_ERR_NONE;
        }
        /// the poll fun called by the executor
        unsafe fn poll(p: OS_TCB_REF) {
            let this = &*(p.as_ptr() as *const OS_TASK_STORAGE<F>);
            let future = Pin::new_unchecked(this.future.as_mut());
            let waker = waker::from_task(p);
            let mut cx = Context::from_waker(&waker);
            match future.poll(&mut cx) {
                Poll::Ready(_) => {
                    this.future.drop_in_place();
                    this.task_tcb.OSTCBStat.despawn();
                }
                Poll::Pending => {}
            }
            mem::forget(waker);
        }
        /// this func will be called to create a new task(TCB)
        fn claim() -> OS_TCB_REF {
            critical_section::with(|cs| {
                let task_storage = ARENA.alloc::<OS_TASK_STORAGE<F>>(cs);
                task_storage.write(OS_TASK_STORAGE::new());
                OS_TCB_REF {
                    ptr: Some(NonNull::new(task_storage as *mut _ as _).unwrap()),
                }
            })
        }
    }
    unsafe impl Sync for OS_TCB_REF {}
    unsafe impl Send for OS_TCB_REF {}
    impl Default for OS_TCB_REF {
        fn default() -> Self {
            OS_TCB_REF { ptr: None }
        }
    }
    impl Deref for OS_TCB_REF {
        type Target = OS_TCB;
        fn deref(&self) -> &Self::Target {
            unsafe { self.ptr.unwrap().as_ref() }
        }
    }
    impl DerefMut for OS_TCB_REF {
        fn deref_mut(&mut self) -> &mut Self::Target {
            unsafe { self.ptr.unwrap().as_mut() }
        }
    }
    impl OS_TCB_REF {
        /// Safety: The pointer must have been obtained with `Task::as_ptr`
        pub(crate) unsafe fn from_ptr(ptr: *const OS_TCB) -> Self {
            Self {
                ptr: Some(NonNull::new_unchecked(ptr as *mut OS_TCB)),
            }
        }
        pub(crate) fn header(self) -> &'static OS_TCB {
            unsafe { self.ptr.unwrap().as_ref() }
        }
        /// The returned pointer is valid for the entire OS_TASK_STORAGE.
        pub(crate) fn as_ptr(self) -> *const OS_TCB {
            self.ptr.unwrap().as_ptr()
        }
    }
    impl<F: Future + 'static> AvailableTask<F> {}
    /// Wake a task by `TaskRef`.
    ///
    /// You can obtain a `TaskRef` from a `Waker` using [`task_from_waker`].
    pub fn wake_task(task: OS_TCB_REF) {
        let header = task.header();
        if header.OSTCBStat.run_enqueue() {
            unsafe {
                let executor = GlobalSyncExecutor.as_ref().unwrap_unchecked();
                executor.enqueue(task);
            }
        }
    }
    #[allow(unused)]
    pub(crate) struct Pender(*mut ());
    #[automatically_derived]
    #[allow(unused)]
    impl ::core::clone::Clone for Pender {
        #[inline]
        fn clone(&self) -> Pender {
            let _: ::core::clone::AssertParamIsClone<*mut ()>;
            *self
        }
    }
    #[automatically_derived]
    #[allow(unused)]
    impl ::core::marker::Copy for Pender {}
    unsafe impl Send for Pender {}
    unsafe impl Sync for Pender {}
    impl Pender {
        #[allow(unused)]
        pub(crate) fn pend(self) {
            extern "Rust" {
                fn __pender(context: *mut ());
            }
            unsafe { __pender(self.0) };
        }
    }
    /// The executor for the uC/OS-II RTOS.
    pub(crate) struct SyncExecutor {
        os_prio_tbl: SyncUnsafeCell<[OS_TCB_REF; (OS_LOWEST_PRIO + 1) as usize]>,
        pub(crate) OSPrioCur: SyncUnsafeCell<OS_PRIO>,
        pub(crate) OSTCBCur: SyncUnsafeCell<OS_TCB_REF>,
        pub(crate) OSPrioHighRdy: SyncUnsafeCell<OS_PRIO>,
        pub(crate) OSTCBHighRdy: SyncUnsafeCell<OS_TCB_REF>,
        _pender: Pender,
        #[cfg(feature = "OS_PRIO_LESS_THAN_64")]
        OSRdyGrp: SyncUnsafeCell<u8>,
        #[cfg(feature = "OS_PRIO_LESS_THAN_64")]
        OSRdyTbl: SyncUnsafeCell<[u8; OS_RDY_TBL_SIZE]>,
        pub(crate) timer_queue: timer_queue::TimerQueue,
        pub(crate) alarm: AlarmHandle,
    }
    impl SyncExecutor {
        fn alarm_callback(ctx: *mut ()) {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::executor".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alarm_callback\",\"disambiguator\":\"3203825671313343529\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alarm_callback\",\"disambiguator\":\"3203825671313343529\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let this: &Self = unsafe { &*(ctx as *const Self) };
            loop {
                unsafe {
                    this.timer_queue.dequeue_expired(RTC_DRIVER.now(), wake_task_no_pend)
                };
                let next_expire = unsafe { this.timer_queue.next_expiration() };
                unsafe {
                    this.timer_queue.set_time.set(next_expire);
                }
                if RTC_DRIVER.set_alarm(this.alarm, next_expire) {
                    break;
                }
            }
            unsafe { this.IntCtxSW() };
        }
        /// The global executor for the uC/OS-II RTOS.
        pub(crate) fn new(pender: Pender) -> Self {
            let alarm = unsafe { RTC_DRIVER.allocate_alarm().unwrap() };
            Self {
                os_prio_tbl: SyncUnsafeCell::new(
                    [OS_TCB_REF::default(); (OS_LOWEST_PRIO + 1) as usize],
                ),
                OSPrioCur: SyncUnsafeCell::new(OS_TASK_IDLE_PRIO),
                OSTCBCur: SyncUnsafeCell::new(OS_TCB_REF::default()),
                OSPrioHighRdy: SyncUnsafeCell::new(OS_TASK_IDLE_PRIO),
                OSTCBHighRdy: SyncUnsafeCell::new(OS_TCB_REF::default()),
                _pender: pender,
                OSRdyGrp: SyncUnsafeCell::new(0),
                OSRdyTbl: SyncUnsafeCell::new([0; OS_RDY_TBL_SIZE]),
                timer_queue: timer_queue::TimerQueue::new(),
                alarm,
            }
        }
        /// set the current to be highrdy
        pub(crate) unsafe fn set_cur_highrdy(&self) {
            let old_task = self.OSTCBCur.get();
            if old_task.is_stk_none() {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the old task stk is none\",\"disambiguator\":\"5326383637547426646\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the old task stk is none\",\"disambiguator\":\"5326383637547426646\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
            }
            self.OSPrioCur.set(self.OSPrioHighRdy.get());
            self.OSTCBCur.set(self.OSTCBHighRdy.get());
        }
        /// Enqueue a task in the task queue
        #[inline(always)]
        unsafe fn enqueue(&self, task: OS_TCB_REF) {
            let prio = task.OSTCBPrio as usize;
            let tmp = self.OSRdyGrp.get_mut();
            *tmp = *tmp | task.OSTCBBitY;
            let tmp = self.OSRdyTbl.get_mut();
            tmp[task.OSTCBY as usize] |= task.OSTCBBitX;
            let tmp = self.os_prio_tbl.get_mut();
            tmp[prio] = task;
            match (&(prio)) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::executor".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the task with prio {} is enqueued\",\"disambiguator\":\"1393697027800772507\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the task with prio {} is enqueued\",\"disambiguator\":\"1393697027800772507\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
        }
        pub(crate) unsafe fn IntCtxSW(&'static self) {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::executor".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"call the IntCtxSW\",\"disambiguator\":\"10908191403510436736\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"call the IntCtxSW\",\"disambiguator\":\"10908191403510436736\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            if critical_section::with(|_| unsafe {
                self.set_highrdy();
                if self.OSPrioHighRdy.get() >= self.OSPrioCur.get() {
                    match (&(self.OSPrioHighRdy.get())) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the PrioHighRdy is {}\",\"disambiguator\":\"15183031489082260747\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the PrioHighRdy is {}\",\"disambiguator\":\"15183031489082260747\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    match (&(self.OSPrioCur.get())) {
                        (arg0) => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the PrioCur is {}\",\"disambiguator\":\"16360234489119290623\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the PrioCur is {}\",\"disambiguator\":\"16360234489119290623\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                defmt::export::fmt(arg0);
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"no need to switch task\",\"disambiguator\":\"636559977918847608\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"no need to switch task\",\"disambiguator\":\"636559977918847608\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    false
                } else {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"need to switch task\",\"disambiguator\":\"2859801580189031178\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"need to switch task\",\"disambiguator\":\"2859801580189031178\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    true
                }
            }) {
                unsafe { self.interrupt_poll() }
            }
        }
        /// this function must be called in the interrupt context, and it will trigger pendsv to switch the task
        /// when this function return, the caller interrupt will also return and the pendsv will run.
        pub(crate) unsafe fn interrupt_poll(&'static self) {
            extern "Rust" {
                fn OSTaskStkInit(stk_ref: NonNull<OS_STK>) -> NonNull<OS_STK>;
                fn restore_thread_task();
            }
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::executor".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"interrupt_poll\",\"disambiguator\":\"14643592471436399642\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"interrupt_poll\",\"disambiguator\":\"14643592471436399642\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let mut task = self.OSTCBHighRdy.get();
            if task.OSTCBStkPtr.is_none() {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the OSTCBStkPtr is null\",\"disambiguator\":\"7754063725652905988\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the OSTCBStkPtr is null\",\"disambiguator\":\"7754063725652905988\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                match (&(task.OSTCBPrio)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the prio of the task is {}\",\"disambiguator\":\"10946005139410475473\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the prio of the task is {}\",\"disambiguator\":\"10946005139410475473\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let layout = Layout::from_size_align(TASK_STACK_SIZE, 4).unwrap();
                match (&(layout)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"layout is {:?}\",\"disambiguator\":\"8160126331884951487\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"layout is {:?}\",\"disambiguator\":\"8160126331884951487\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let mut stk = alloc_stack(layout);
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"exit the alloc_stack\",\"disambiguator\":\"3815637950924160681\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"exit the alloc_stack\",\"disambiguator\":\"3815637950924160681\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                match (&(stk.STK_REF)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the stk_ref is {:?}\",\"disambiguator\":\"15769535929028129352\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the stk_ref is {:?}\",\"disambiguator\":\"15769535929028129352\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                stk.STK_REF = OSTaskStkInit(stk.STK_REF);
                task.OSTCBStkPtr = Some(stk);
            }
            unsafe {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"restore the task/thread\",\"disambiguator\":\"16183550542933218603\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"restore the task/thread\",\"disambiguator\":\"16183550542933218603\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                restore_thread_task()
            };
        }
        /// since when it was called, there is no task running, we need poll all the task that is ready in bitmap
        pub(crate) unsafe fn poll(&'static self) -> ! {
            RTC_DRIVER
                .set_alarm_callback(
                    self.alarm,
                    Self::alarm_callback,
                    self as *const _ as *mut (),
                );
            loop {
                let mut task = self.OSTCBHighRdy.get();
                self.OSPrioCur.set(task.OSTCBPrio);
                self.OSTCBCur.set(task);
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::executor".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in the poll task loop\",\"disambiguator\":\"8930406093499997138\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in the poll task loop\",\"disambiguator\":\"8930406093499997138\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                if task.OSTCBStkPtr.is_none() {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"poll the task\",\"disambiguator\":\"10389482352268945997\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"poll the task\",\"disambiguator\":\"10389482352268945997\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    task.OS_POLL_FN.get().unwrap_unchecked()(task);
                } else {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::executor".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"resume the task\",\"disambiguator\":\"12790393405456727770\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"resume the task\",\"disambiguator\":\"12790393405456727770\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    task.restore_context_from_stk();
                }
                critical_section::with(|_| {
                    self.set_task_unready(task);
                    task.OSTCBStkPtr = None;
                });
                let mut next_expire = self.timer_queue.update(task);
                if critical_section::with(|_| {
                    if next_expire < *self.timer_queue.set_time.get_unmut() {
                        self.timer_queue.set_time.set(next_expire);
                        true
                    } else {
                        false
                    }
                }) {
                    while !RTC_DRIVER.set_alarm(self.alarm, next_expire) {
                        match () {
                            () => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path = "ucosii::executor".as_bytes();
                                            if if 6usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                    && module_path[2usize] == 111u8
                                                    && module_path[3usize] == 115u8
                                                    && module_path[4usize] == 105u8
                                                    && module_path[5usize] == 105u8
                                                    && if 6usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[6usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe { defmt::export::acquire() };
                                    defmt::export::header(
                                        &{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"set_alarm return false\",\"disambiguator\":\"5120734952328443115\",\"crate_name\":\"ucosii\"}"]
                                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"set_alarm return false\",\"disambiguator\":\"5120734952328443115\",\"crate_name\":\"ucosii\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        },
                                    );
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        self.timer_queue
                            .dequeue_expired(RTC_DRIVER.now(), wake_task_no_pend);
                        next_expire = unsafe { self.timer_queue.next_expiration() };
                        unsafe {
                            self.timer_queue.set_time.set(next_expire);
                        }
                    }
                }
                critical_section::with(|_| self.set_highrdy());
            }
        }
        pub(crate) unsafe fn set_highrdy(&self) {
            let tmp = self.OSRdyGrp.get_unmut();
            if *tmp == 0 {
                self.OSPrioHighRdy.set(OS_TASK_IDLE_PRIO);
                self.OSTCBHighRdy
                    .set(self.os_prio_tbl.get_unmut()[OS_TASK_IDLE_PRIO as usize]);
                return;
            }
            let prio = tmp.trailing_zeros() as usize;
            let tmp = self.OSRdyTbl.get_unmut();
            let prio = prio * 8 + tmp[prio].trailing_zeros() as usize;
            match (&(prio)) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::executor".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the highrdy task's prio is {}\",\"disambiguator\":\"8646443476300152004\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the highrdy task's prio is {}\",\"disambiguator\":\"8646443476300152004\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            self.OSPrioHighRdy.set(prio as OS_PRIO);
            self.OSTCBHighRdy.set(self.os_prio_tbl.get_unmut()[prio]);
        }
        pub(crate) unsafe fn set_task_unready(&self, task: OS_TCB_REF) {
            critical_section::with(|_| {
                let tmp = self.OSRdyTbl.get_mut();
                tmp[task.OSTCBY as usize] &= !task.OSTCBBitX;
                if tmp[task.OSTCBY as usize] == 0 {
                    let tmp = self.OSRdyGrp.get_mut();
                    *tmp &= !task.OSTCBBitY;
                }
            });
        }
        pub fn prio_exist(&self, prio: INT8U) -> bool {
            let prio_tbl: &[OS_TCB_REF; (OS_LOWEST_PRIO + 1) as usize];
            prio_tbl = self.os_prio_tbl.get_unmut();
            prio_tbl[prio as USIZE].ptr.is_some()
        }
        pub fn reserve_bit(&self, prio: INT8U) {
            let prio_tbl: &mut [OS_TCB_REF; (OS_LOWEST_PRIO + 1) as usize];
            prio_tbl = self.os_prio_tbl.get_mut();
            prio_tbl[prio as USIZE].ptr = Some(NonNull::dangling());
        }
        pub fn clear_bit(&self, prio: INT8U) {
            let prio_tbl: &mut [OS_TCB_REF; (OS_LOWEST_PRIO + 1) as usize];
            prio_tbl = self.os_prio_tbl.get_mut();
            prio_tbl[prio as USIZE].ptr = None;
        }
    }
    /// Wake a task by `TaskRef`.
    pub fn wake_task_no_pend(task: OS_TCB_REF) {
        match () {
            () => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "ucosii::executor".as_bytes();
                            if if 6usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                    && module_path[2usize] == 111u8
                                    && module_path[3usize] == 115u8
                                    && module_path[4usize] == 105u8
                                    && module_path[5usize] == 105u8
                                    && if 6usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[6usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    unsafe { defmt::export::acquire() };
                    defmt::export::header(
                        &{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"wake_task_no_pend\",\"disambiguator\":\"9802051959675534554\",\"crate_name\":\"ucosii\"}"]
                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"wake_task_no_pend\",\"disambiguator\":\"9802051959675534554\",\"crate_name\":\"ucosii\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        },
                    );
                    unsafe { defmt::export::release() }
                }
            }
        };
        unsafe {
            let executor = GlobalSyncExecutor.as_ref().unwrap();
            executor.enqueue(task);
        }
    }
}
/// the mod of semaphore of uC/OS-II kernel
pub mod os_sem {}
/// the task interface of uC/OS-II kernel
pub mod os_task {
    use alloc::string::ToString;
    use core::alloc::Layout;
    use core::future::Future;
    use core::sync::atomic::Ordering::Acquire;
    use defmt::info;
    use crate::cfg::OS_LOWEST_PRIO;
    use crate::executor::{GlobalSyncExecutor, OS_TASK_STORAGE};
    use crate::heap::stack_allocator::{dealloc_stack, stk_from_ptr};
    use crate::port::{INT8U, OS_STK};
    use crate::ucosii::{OSIntNesting, OSRunning, OS_ERR_STATE};
    const DEFAULT_REVOKE_STACK_SIZE: usize = 128;
    /// the trait to check whether the return type is unit or never return
    pub trait ReturnUnitOrNeverReturn {}
    impl ReturnUnitOrNeverReturn for ! {}
    impl ReturnUnitOrNeverReturn for () {}
    /// Create a task in uC/OS-II kernel. This func is used by C
    pub fn OSTaskCreate<F, R>(
        task: F,
        p_arg: *mut (),
        _ptos: *mut OS_STK,
        prio: INT8U,
    ) -> OS_ERR_STATE
    where
        F: FnOnce(*mut ()) -> R + 'static,
        R: ReturnUnitOrNeverReturn,
    {
        if prio > OS_LOWEST_PRIO as u8 {
            return OS_ERR_STATE::OS_ERR_PRIO_INVALID;
        }
        let future_func = move || async move { task(p_arg) };
        if !_ptos.is_null() {
            let layout = Layout::from_size_align(DEFAULT_REVOKE_STACK_SIZE, 4).unwrap();
            let heap_ptr = unsafe {
                (_ptos as *mut u8).offset(-(DEFAULT_REVOKE_STACK_SIZE as isize))
            };
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::os_task".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"Task Create\",\"disambiguator\":\"6901776244536121132\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"Task Create\",\"disambiguator\":\"6901776244536121132\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let mut stk = stk_from_ptr(heap_ptr as *mut u8, layout);
            dealloc_stack(&mut stk);
        }
        return init_task(prio, future_func);
    }
    /// Create a task in uC/OS-II kernel. This func is used by async Rust
    pub fn RustOSTaskCreate<F, FutFn>(
        task: FutFn,
        p_arg: *mut (),
        _ptos: *mut OS_STK,
        prio: INT8U,
    ) -> OS_ERR_STATE
    where
        F: Future + 'static,
        FutFn: FnOnce(*mut ()) -> F + 'static,
    {
        let future_func = || task(p_arg);
        if !_ptos.is_null() {
            let layout = Layout::from_size_align(DEFAULT_REVOKE_STACK_SIZE, 4).unwrap();
            let heap_ptr = unsafe {
                (_ptos as *mut u8).offset(-(DEFAULT_REVOKE_STACK_SIZE as isize))
            };
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::os_task".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"Rust Create\",\"disambiguator\":\"14262900609575237404\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"Rust Create\",\"disambiguator\":\"14262900609575237404\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let mut stk = stk_from_ptr(heap_ptr as *mut u8, layout);
            dealloc_stack(&mut stk);
        }
        return init_task(prio, future_func);
    }
    fn init_task<F: Future + 'static>(
        prio: INT8U,
        future_func: impl FnOnce() -> F,
    ) -> OS_ERR_STATE {
        if OSIntNesting.load(Acquire) > 0 {
            return OS_ERR_STATE::OS_ERR_TASK_CREATE_ISR;
        }
        if critical_section::with(|_cs| {
            let executor = GlobalSyncExecutor.as_ref().unwrap();
            if executor.prio_exist(prio) {
                return true;
            } else {
                executor.reserve_bit(prio);
                return false;
            }
        }) {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::os_task".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the prio is exist\",\"disambiguator\":\"18375827883750599928\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the prio is exist\",\"disambiguator\":\"18375827883750599928\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            return OS_ERR_STATE::OS_ERR_PRIO_EXIST;
        }
        let err = OS_TASK_STORAGE::init(
            prio,
            0,
            0 as *mut (),
            0,
            "".to_string(),
            future_func,
        );
        if err == OS_ERR_STATE::OS_ERR_NONE {
            if OSRunning.load(Acquire) {
                unsafe {
                    GlobalSyncExecutor.as_ref().unwrap().IntCtxSW();
                }
            }
        } else {
            critical_section::with(|_cs| {
                let executor = GlobalSyncExecutor.as_ref().unwrap();
                executor.clear_bit(prio);
            })
        }
        return err;
    }
}
/// the mod of time of uC/OS-II kernel
pub mod os_time {
    use defmt::info;
    use crate::executor::{self, wake_task_no_pend, GlobalSyncExecutor};
    use crate::port::time_driver::{Driver, RTC_DRIVER};
    use crate::port::INT32U;
    /// the mod of duration of uC/OS-II kernel
    pub mod duration {
        use core::ops::Add;
        use crate::cfg::TICK_HZ;
        /// Represents the difference between two [Instant](struct.Instant.html)s
        pub struct Duration {
            pub(crate) ticks: u64,
        }
        impl defmt::Format for Duration
        where
            u64: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::os_time::duration".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"11063873304532056878\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"11063873304532056878\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_derived\",\"data\":\"Duration {{ ticks: {=?:?} }}\",\"disambiguator\":\"4647789192439117519\",\"crate_name\":\"ucosii\"}"]
                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_derived\",\"data\":\"Duration {{ ticks: {=?:?} }}\",\"disambiguator\":\"4647789192439117519\",\"crate_name\":\"ucosii\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { ticks } => {
                        defmt::export::fmt(ticks);
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Duration {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Duration",
                    "ticks",
                    &&self.ticks,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Duration {
            #[inline]
            fn default() -> Duration {
                Duration {
                    ticks: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Duration {}
        #[automatically_derived]
        impl ::core::clone::Clone for Duration {
            #[inline]
            fn clone(&self) -> Duration {
                let _: ::core::clone::AssertParamIsClone<u64>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Duration {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Duration {
            #[inline]
            fn eq(&self, other: &Duration) -> bool {
                self.ticks == other.ticks
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Duration {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u64>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Duration {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Duration,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.ticks, &other.ticks)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Duration {
            #[inline]
            fn cmp(&self, other: &Duration) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.ticks, &other.ticks)
            }
        }
        const fn gcd(a: u64, b: u64) -> u64 {
            if b == 0 { a } else { gcd(b, a % b) }
        }
        pub(crate) const GCD_1K: u64 = gcd(TICK_HZ, 1_000);
        pub(crate) const GCD_1M: u64 = gcd(TICK_HZ, 1_000_000);
        impl Duration {
            /// Creates a duration from the specified number of clock ticks
            pub const fn from_ticks(ticks: u64) -> Duration {
                Duration { ticks }
            }
            /// Creates a duration from the specified number of seconds, rounding up.
            pub const fn from_secs(secs: u64) -> Duration {
                Duration { ticks: secs * TICK_HZ }
            }
            /// Creates a duration from the specified number of milliseconds, rounding up.
            pub const fn from_millis(millis: u64) -> Duration {
                Duration {
                    ticks: div_ceil(millis * (TICK_HZ / GCD_1K), 1000 / GCD_1K),
                }
            }
            /// Creates a duration from the specified number of microseconds, rounding up.
            /// NOTE: Delays this small may be inaccurate.
            pub const fn from_micros(micros: u64) -> Duration {
                Duration {
                    ticks: div_ceil(micros * (TICK_HZ / GCD_1M), 1_000_000 / GCD_1M),
                }
            }
            /// Creates a duration from the specified number of seconds, rounding down.
            pub const fn from_secs_floor(secs: u64) -> Duration {
                Duration { ticks: secs * TICK_HZ }
            }
            /// Creates a duration from the specified number of milliseconds, rounding down.
            pub const fn from_millis_floor(millis: u64) -> Duration {
                Duration {
                    ticks: millis * (TICK_HZ / GCD_1K) / (1000 / GCD_1K),
                }
            }
            /// Creates a duration from the specified number of microseconds, rounding down.
            /// NOTE: Delays this small may be inaccurate.
            pub const fn from_micros_floor(micros: u64) -> Duration {
                Duration {
                    ticks: micros * (TICK_HZ / GCD_1M) / (1_000_000 / GCD_1M),
                }
            }
            /// Adds one Duration to another, returning a new Duration or None in the event of an overflow.
            pub fn checked_add(self, rhs: Duration) -> Option<Duration> {
                self.ticks.checked_add(rhs.ticks).map(|ticks| Duration { ticks })
            }
        }
        impl Add for Duration {
            type Output = Duration;
            fn add(self, rhs: Duration) -> Duration {
                self.checked_add(rhs).expect("overflow when adding durations")
            }
        }
        #[inline]
        const fn div_ceil(num: u64, den: u64) -> u64 {
            (num + den - 1) / den
        }
    }
    /// the mod of instant of uC/OS-II kernel
    pub mod instant {
        use core::ops::Add;
        use crate::port::time_driver::{Driver, RTC_DRIVER};
        use super::duration::Duration;
        #[allow(unused)]
        /// An Instant in time, based on the MCU's clock ticks since startup.
        pub struct Instant {
            ticks: u64,
        }
        impl defmt::Format for Instant
        where
            u64: defmt::Format,
        {
            fn format(&self, f: defmt::Formatter) {
                {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::os_time::instant".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"13909251448238066989\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_error\",\"data\":\"panicked at 'internal error: entered unreachable code'\",\"disambiguator\":\"13909251448238066989\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    defmt::export::panic()
                }
            }
            fn _format_tag() -> defmt::Str {
                {
                    defmt::export::make_istr({
                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_derived\",\"data\":\"Instant {{ ticks: {=?:?} }}\",\"disambiguator\":\"9825892581989874964\",\"crate_name\":\"ucosii\"}"]
                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_derived\",\"data\":\"Instant {{ ticks: {=?:?} }}\",\"disambiguator\":\"9825892581989874964\",\"crate_name\":\"ucosii\"}"]
                        static S: u8 = 0;
                        &S as *const u8 as u16
                    })
                }
            }
            fn _format_data(&self) {
                match self {
                    Self { ticks } => {
                        defmt::export::fmt(ticks);
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::fmt::Debug for Instant {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Instant",
                    "ticks",
                    &&self.ticks,
                )
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::marker::Copy for Instant {}
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::clone::Clone for Instant {
            #[inline]
            fn clone(&self) -> Instant {
                let _: ::core::clone::AssertParamIsClone<u64>;
                *self
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::marker::StructuralPartialEq for Instant {}
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::PartialEq for Instant {
            #[inline]
            fn eq(&self, other: &Instant) -> bool {
                self.ticks == other.ticks
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::Eq for Instant {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u64>;
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::PartialOrd for Instant {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Instant,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.ticks, &other.ticks)
            }
        }
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::cmp::Ord for Instant {
            #[inline]
            fn cmp(&self, other: &Instant) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.ticks, &other.ticks)
            }
        }
        impl Instant {
            /// The smallest (earliest) value that can be represented by the `Instant` type.
            pub const MIN: Instant = Instant { ticks: u64::MIN };
            /// The largest (latest) value that can be represented by the `Instant` type.
            pub const MAX: Instant = Instant { ticks: u64::MAX };
            /// Returns an Instant representing the current time.
            pub fn now() -> Instant {
                Instant { ticks: RTC_DRIVER.now() }
            }
            /// Adds one Duration to self, returning a new `Instant` or None in the event of an overflow.
            pub fn checked_add(&self, duration: Duration) -> Option<Instant> {
                self.ticks.checked_add(duration.ticks).map(|ticks| Instant { ticks })
            }
            /// Tick count since system boot.
            pub const fn as_ticks(&self) -> u64 {
                self.ticks
            }
        }
        impl Add<Duration> for Instant {
            type Output = Instant;
            fn add(self, other: Duration) -> Instant {
                self.checked_add(other)
                    .expect("overflow when adding duration to instant")
            }
        }
    }
    /// the mod of timer of uC/OS-II kernel
    pub mod timer {
        use core::future::Future;
        use core::pin::Pin;
        use core::task::{Context, Poll, Waker};
        use super::duration::Duration;
        use super::instant::Instant;
        #[allow(unused)]
        /// A future that completes at a specified [Instant](struct.Instant.html).
        #[must_use = "futures do nothing unless you `.await` or poll them"]
        pub struct Timer {
            expires_at: Instant,
            yielded_once: bool,
        }
        extern "Rust" {
            fn _embassy_time_schedule_wake(at: u64, waker: &Waker);
        }
        /// Schedule the given waker to be woken at `at`.
        pub fn schedule_wake(at: u64, waker: &Waker) {
            unsafe { _embassy_time_schedule_wake(at, waker) }
        }
        impl Future for Timer {
            type Output = ();
            fn poll(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
            ) -> Poll<Self::Output> {
                if self.yielded_once && self.expires_at <= Instant::now() {
                    Poll::Ready(())
                } else {
                    schedule_wake(self.expires_at.as_ticks(), cx.waker());
                    self.yielded_once = true;
                    Poll::Pending
                }
            }
        }
        impl Timer {
            /// Expire at specified [Instant](struct.Instant.html)
            pub fn at(expires_at: Instant) -> Self {
                Self {
                    expires_at,
                    yielded_once: false,
                }
            }
            /// Expire after specified [Duration](struct.Duration.html).
            /// This can be used as a `sleep` abstraction.
            ///
            /// Example:
            /// ``` no_run
            /// use embassy_time::{Duration, Timer};
            ///
            /// #[embassy_executor::task]
            /// async fn demo_sleep_seconds() {
            ///     // suspend this task for one second.
            ///     Timer::after(Duration::from_secs(1)).await;
            /// }
            /// ```
            pub fn after(duration: Duration) -> Self {
                Self {
                    expires_at: Instant::now() + duration,
                    yielded_once: false,
                }
            }
            /// Expire after the specified number of ticks.
            ///
            /// This method is a convenience wrapper for calling `Timer::after(Duration::from_ticks())`.
            /// For more details, refer to [`Timer::after()`] and [`Duration::from_ticks()`].
            #[inline]
            pub fn after_ticks(ticks: u64) -> Self {
                Self::after(Duration::from_ticks(ticks))
            }
            /// Expire after the specified number of microseconds.
            ///
            /// This method is a convenience wrapper for calling `Timer::after(Duration::from_micros())`.
            /// For more details, refer to [`Timer::after()`] and [`Duration::from_micros()`].
            #[inline]
            pub fn after_micros(micros: u64) -> Self {
                Self::after(Duration::from_micros(micros))
            }
            /// Expire after the specified number of milliseconds.
            ///
            /// This method is a convenience wrapper for calling `Timer::after(Duration::from_millis())`.
            /// For more details, refer to [`Timer::after`] and [`Duration::from_millis()`].
            #[inline]
            pub fn after_millis(millis: u64) -> Self {
                Self::after(Duration::from_millis(millis))
            }
            /// Expire after the specified number of seconds.
            ///
            /// This method is a convenience wrapper for calling `Timer::after(Duration::from_secs())`.
            /// For more details, refer to [`Timer::after`] and [`Duration::from_secs()`].
            #[inline]
            pub fn after_secs(secs: u64) -> Self {
                Self::after(Duration::from_secs(secs))
            }
        }
    }
    /// init the Timer as the Systick
    pub fn OSTimerInit() {
        RTC_DRIVER.init();
    }
    /// we have to make this delay acting like preemptive delay
    pub fn OSTimeDly(_ticks: INT32U) {
        unsafe {
            delay_tick(_ticks);
        }
    }
    pub(crate) unsafe fn delay_tick(_ticks: INT32U) {
        let executor = GlobalSyncExecutor.as_ref().unwrap();
        let task = executor.OSTCBCur.get_mut();
        task.expires_at.set(RTC_DRIVER.now() + _ticks as u64);
        match (&(task.expires_at.get_unmut())) {
            (arg0) => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "ucosii::os_time".as_bytes();
                            if if 6usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                    && module_path[2usize] == 111u8
                                    && module_path[3usize] == 115u8
                                    && module_path[4usize] == 105u8
                                    && module_path[5usize] == 105u8
                                    && if 6usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[6usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    unsafe { defmt::export::acquire() };
                    defmt::export::header(
                        &{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the expire time is {}\",\"disambiguator\":\"8016429666784642177\",\"crate_name\":\"ucosii\"}"]
                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the expire time is {}\",\"disambiguator\":\"8016429666784642177\",\"crate_name\":\"ucosii\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        },
                    );
                    defmt::export::fmt(arg0);
                    unsafe { defmt::export::release() }
                }
            }
        };
        critical_section::with(|_| {
            executor.set_task_unready(*task);
        });
        let mut next_expire = executor.timer_queue.update(*task);
        match (&(next_expire)) {
            (arg0) => {
                if {
                    const CHECK: bool = {
                        const fn check() -> bool {
                            let module_path = "ucosii::os_time".as_bytes();
                            if if 6usize > module_path.len() {
                                false
                            } else {
                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                    && module_path[2usize] == 111u8
                                    && module_path[3usize] == 115u8
                                    && module_path[4usize] == 105u8
                                    && module_path[5usize] == 105u8
                                    && if 6usize == module_path.len() {
                                        true
                                    } else {
                                        module_path[6usize] == b':'
                                    }
                            } {
                                return true;
                            }
                            false
                        }
                        check()
                    };
                    CHECK
                } {
                    unsafe { defmt::export::acquire() };
                    defmt::export::header(
                        &{
                            defmt::export::make_istr({
                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the next_expire is {}\",\"disambiguator\":\"15963606043525173210\",\"crate_name\":\"ucosii\"}"]
                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the next_expire is {}\",\"disambiguator\":\"15963606043525173210\",\"crate_name\":\"ucosii\"}"]
                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                            })
                        },
                    );
                    defmt::export::fmt(arg0);
                    unsafe { defmt::export::release() }
                }
            }
        };
        if critical_section::with(|_| {
            if next_expire < *executor.timer_queue.set_time.get_unmut() {
                executor.timer_queue.set_time.set(next_expire);
                true
            } else {
                false
            }
        }) {
            while !RTC_DRIVER.set_alarm(executor.alarm, next_expire) {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::os_time".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"set_alarm return false\",\"disambiguator\":\"11042483141096184076\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"set_alarm return false\",\"disambiguator\":\"11042483141096184076\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                executor
                    .timer_queue
                    .dequeue_expired(RTC_DRIVER.now(), wake_task_no_pend);
                next_expire = unsafe { executor.timer_queue.next_expiration() };
                executor.timer_queue.set_time.set(next_expire);
            }
        }
        if critical_section::with(|_| {
            executor.set_highrdy();
            executor.OSPrioHighRdy != executor.OSPrioCur
        }) {
            critical_section::with(|_| {
                GlobalSyncExecutor.as_ref().unwrap().set_highrdy()
            });
            GlobalSyncExecutor.as_ref().unwrap().interrupt_poll();
        }
    }
}
/// the mod of timer of uC/OS-II kernel
pub mod os_tmr {}
/// need to import port here
pub mod port {
    #![allow(non_camel_case_types)]
    use stm32_metapac::timer::TimGp16;
    /// Unsigned  8 bit quantity
    pub type BOOLEAN = bool;
    /// Unsigned  8 bit quantity
    pub type INT8U = u8;
    /// Signed    8 bit quantity
    pub type INT8S = i8;
    /// Unsigned 16 bit quantity
    pub type INT16U = u16;
    /// Signed   16 bit quantity
    pub type INT16S = i16;
    /// Unsigned 32 bit quantity
    pub type INT32U = u32;
    /// Signed   32 bit quantity
    pub type INT32S = i32;
    /// Single precision floating point
    pub type FP32 = f32;
    /// Double precision floating point
    pub type FP64 = f64;
    /// the ptr size. define this to use raw ptr
    pub type PTR = *mut ();
    /// the usize type used in array
    pub type USIZE = usize;
    /// the u64 type
    pub type INT64U = u64;
    /// Each stack entry is 32-bit wide
    pub type OS_STK = usize;
    /// Define size of CPU status register (PSR = 32 bits)
    pub type OS_CPU_SR = u32;
    #[cfg(feature = "time_driver_tim3")]
    /// set the time driver to be Timer3
    pub const TIMER: TimGp16 = stm32_metapac::TIM3;
    pub mod os_cpu {
        //! about the cpu
        use core::arch::asm;
        use core::ptr::NonNull;
        use cortex_m_rt::exception;
        use defmt::info;
        use super::OS_STK;
        use crate::executor::{GlobalSyncExecutor, OS_TCB};
        use crate::heap::stack_allocator::PROGRAM_STACK;
        /// finish the init part of the CPU/MCU
        pub fn OSInitHookBegin() {}
        const NVIC_INT_CTRL: u32 = 0xE000ED04;
        const NVIC_PENDSVSET: u32 = 0x10000000;
        #[no_mangle]
        #[inline]
        /// the function to start the first task
        pub extern "Rust" fn restore_thread_task() {
            unsafe {
                asm!(
                    "STR     R1, [R0]", in ("r0") NVIC_INT_CTRL, in ("r1") NVIC_PENDSVSET
                )
            }
        }
        const _: () = {
            let _ = cortex_m_rt::Exception::PendSV;
        };
        #[doc(hidden)]
        #[export_name = "PendSV"]
        pub unsafe extern "C" fn __cortex_m_rt_PendSV_trampoline() {
            __cortex_m_rt_PendSV()
        }
        fn __cortex_m_rt_PendSV() {
            {
                exception::PendSV;
            }
            unsafe {
                asm!(
                    "CPSID I\nMRS     R0, PSP\nSTMFD   R0!, {{R4-R11, R14}}\nMSR     PSP, R0",
                    options(preserves_flags, nostack)
                );
            }
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::port::os_cpu".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"entering pendsv\",\"disambiguator\":\"5511319756446349825\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"entering pendsv\",\"disambiguator\":\"5511319756446349825\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let stk_ptr: crate::heap::stack_allocator::OS_STK_REF = GlobalSyncExecutor
                .as_ref()
                .unwrap()
                .OSTCBHighRdy
                .get_mut()
                .take_stk();
            let program_stk_ptr = stk_ptr.STK_REF.as_ptr();
            let mut old_stk = PROGRAM_STACK.swap(stk_ptr);
            let TCB: &OS_TCB;
            if GlobalSyncExecutor.as_ref().unwrap().OSPrioCur
                != GlobalSyncExecutor.as_ref().unwrap().OSPrioHighRdy
            {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::port::os_cpu".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"need to save the context\",\"disambiguator\":\"15184922379357447464\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"need to save the context\",\"disambiguator\":\"15184922379357447464\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let old_stk_ptr: *mut usize;
                unsafe {
                    asm!(
                        "MRS     R0, PSP", out("r0") old_stk_ptr,
                        options(preserves_flags, nostack)
                    )
                }
                old_stk.STK_REF = NonNull::new(old_stk_ptr as *mut OS_STK).unwrap();
                match (&(old_stk_ptr)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::port::os_cpu".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in pendsv, we set the stack pointer to {:?}\",\"disambiguator\":\"1039754898546359389\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in pendsv, we set the stack pointer to {:?}\",\"disambiguator\":\"1039754898546359389\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let task_cur = GlobalSyncExecutor.as_ref().unwrap().OSTCBCur.get_mut();
                task_cur.set_stk(old_stk);
                unsafe {
                    TCB = task_cur.ptr.unwrap().as_ref();
                }
                if task_cur.is_stk_none() {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::port::os_cpu".as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the task stk is none\",\"disambiguator\":\"15498251195801369903\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the task stk is none\",\"disambiguator\":\"15498251195801369903\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                }
                unsafe {
                    GlobalSyncExecutor.as_ref().unwrap().set_cur_highrdy();
                }
            } else {
                drop(old_stk);
            }
            match (&(program_stk_ptr)) {
                (arg0) => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::port::os_cpu".as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"trying to restore, the new stack pointer is {:?}\",\"disambiguator\":\"3708388502300155862\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"trying to restore, the new stack pointer is {:?}\",\"disambiguator\":\"3708388502300155862\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        defmt::export::fmt(arg0);
                        unsafe { defmt::export::release() }
                    }
                }
            };
            unsafe {
                asm!(
                    "LDMFD   R0!, {{R4-R11, R14}}\nMSR     PSP, R0\nCPSIE   I\nBX      LR",
                    in ("r0") program_stk_ptr, options(preserves_flags, nostack)
                )
            }
        }
        #[no_mangle]
        /// the function when there is no task to run
        pub extern "Rust" fn run_idle() {
            unsafe {
                asm!("wfe");
            }
        }
        /// the context structure store in stack
        #[repr(C, align(4))]
        struct UcStk {
            r4: u32,
            r5: u32,
            r6: u32,
            r7: u32,
            r8: u32,
            r9: u32,
            r10: u32,
            r11: u32,
            r14: u32,
            r0: u32,
            r1: u32,
            r2: u32,
            r3: u32,
            r12: u32,
            lr: u32,
            pc: u32,
            xpsr: u32,
        }
        const CONTEXT_STACK_SIZE: usize = 16;
        #[no_mangle]
        #[inline]
        /// the function to mock/init the stack of the task
        /// set the pc to the executor's poll function
        pub extern "Rust" fn OSTaskStkInit(stk_ref: NonNull<OS_STK>) -> NonNull<OS_STK> {
            let executor_function_ptr: fn() = || unsafe {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::port::os_cpu".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"entering the executor function\",\"disambiguator\":\"9739671119437669252\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"entering the executor function\",\"disambiguator\":\"9739671119437669252\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                GlobalSyncExecutor.as_ref().unwrap().poll();
            };
            let executor_function_ptr = executor_function_ptr as *const () as usize;
            let ptos = stk_ref.as_ptr() as *mut usize;
            let mut ptos = ((unsafe { ptos.offset(1) } as usize) & 0xFFFFFFF8)
                as *mut usize;
            ptos = unsafe { ptos.offset(-(CONTEXT_STACK_SIZE as isize + 1) as isize) };
            let psp = ptos as *mut UcStk;
            unsafe {
                (*psp).r0 = 0;
                (*psp).r1 = 0x01010101;
                (*psp).r2 = 0x02020202;
                (*psp).r3 = 0x03030303;
                (*psp).r4 = 0x04040404;
                (*psp).r5 = 0x05050505;
                (*psp).r6 = 0x06060606;
                (*psp).r7 = 0x07070707;
                (*psp).r8 = 0x08080808;
                (*psp).r9 = 0x09090909;
                (*psp).r10 = 0x10101010;
                (*psp).r11 = 0x11111111;
                (*psp).r12 = 0x12121212;
                (*psp).r14 = 0xFFFFFFFD;
                (*psp).lr = 0;
                (*psp).pc = executor_function_ptr as u32;
                (*psp).xpsr = 0x01000000;
            }
            NonNull::new(ptos as *mut OS_STK).unwrap()
        }
        #[no_mangle]
        #[inline]
        /// the function to set the program stack
        pub extern "Rust" fn set_program_sp(sp: *mut u8) {
            unsafe {
                asm!("MSR psp, r0", in ("r0") sp, options(preserves_flags, nostack))
            }
        }
        #[no_mangle]
        #[inline]
        /// the function to set the interrupt stack and change the control register to use the psp
        pub extern "Rust" fn set_int_change_2_psp(int_ptr: *mut u8) {
            unsafe {
                asm!(
                    "MSR msp, r1\nMRS r0, control\nORR r0, r0, #2\nMSR control, r0", in
                    ("r1") int_ptr, options(preserves_flags, nostack)
                )
            }
        }
    }
    /// the time driver
    pub mod time_driver {
        use core::cell::Cell;
        use core::sync::atomic::{compiler_fence, AtomicU32, AtomicU8, Ordering};
        use core::{mem, ptr};
        use cortex_m::peripheral::NVIC;
        use critical_section::{CriticalSection, Mutex};
        use defmt::info;
        use stm32_metapac::flash::vals::Latency;
        use stm32_metapac::rcc::vals::*;
        use stm32_metapac::timer::{regs, vals};
        use stm32_metapac::{Interrupt, FLASH, RCC};
        use crate::cfg::{APB_HZ, TICK_HZ};
        use crate::executor::waker;
        use crate::port::{BOOLEAN, INT16U, INT32U, INT64U, INT8U, TIMER, USIZE};
        #[cfg(
            not(
                any(
                    feature = "time_driver_tim9",
                    feature = "time_driver_tim12",
                    feature = "time_driver_tim15",
                    feature = "time_driver_tim21",
                    feature = "time_driver_tim22"
                )
            )
        )]
        const ALARM_COUNT: USIZE = 3;
        #[cfg(feature = "time_driver_tim3")]
        #[no_mangle]
        /// TIM3 interrupt handler
        pub extern "C" fn TIM3() {
            RTC_DRIVER.on_interrupt();
        }
        const DISABLE: bool = false;
        const ENABLE: bool = true;
        struct AlarmState {
            timestamp: Cell<INT64U>,
            callback: Cell<*const ()>,
            ctx: Cell<*mut ()>,
        }
        /// Handle to an alarm.
        pub struct AlarmHandle {
            id: INT8U,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for AlarmHandle {
            #[inline]
            fn clone(&self) -> AlarmHandle {
                let _: ::core::clone::AssertParamIsClone<INT8U>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for AlarmHandle {}
        pub(crate) struct RtcDriver {
            /// Number of 2^15 periods elapsed since boot.
            period: AtomicU32,
            alarm_count: AtomicU8,
            /// Timestamp at which to fire alarm. u64::MAX if no alarm is scheduled.
            alarms: Mutex<[AlarmState; ALARM_COUNT]>,
        }
        /// Time driver
        pub trait Driver: Send + Sync + 'static {
            /// Return the current timestamp in ticks.
            ///
            /// Implementations MUST ensure that:
            /// - This is guaranteed to be monotonic, i.e. a call to now() will always return
            ///   a greater or equal value than earler calls. Time can't "roll backwards".
            /// - It "never" overflows. It must not overflow in a sufficiently long time frame, say
            ///   in 10_000 years (Human civilization is likely to already have self-destructed
            ///   10_000 years from now.). This means if your hardware only has 16bit/32bit timers
            ///   you MUST extend them to 64-bit, for example by counting overflows in software,
            ///   or chaining multiple timers together.
            fn now(&self) -> INT64U;
            /// Try allocating an alarm handle. Returns None if no alarms left.
            /// Initially the alarm has no callback set, and a null `ctx` pointer.
            ///
            /// # Safety
            /// It is UB to make the alarm fire before setting a callback.
            unsafe fn allocate_alarm(&self) -> Option<AlarmHandle>;
            /// Sets the callback function to be called when the alarm triggers.
            /// The callback may be called from any context (interrupt or thread mode).
            /// by noahthis func will not be used in the current project
            fn set_alarm_callback(
                &self,
                alarm: AlarmHandle,
                callback: fn(*mut ()),
                ctx: *mut (),
            );
            /// Sets an alarm at the given timestamp. When the current timestamp reaches the alarm
            /// timestamp, the provided callback function will be called.
            ///
            /// The `Driver` implementation should guarantee that the alarm callback is never called synchronously from `set_alarm`.
            /// Rather - if `timestamp` is already in the past - `false` should be returned and alarm should not be set,
            /// or alternatively, the driver should return `true` and arrange to call the alarm callback as soon as possible, but not synchronously.
            /// There is a rare third possibility that the alarm was barely in the future, and by the time it was enabled, it had slipped into the
            /// past.  This is can be detected by double-checking that the alarm is still in the future after enabling it; if it isn't, `false`
            /// should also be returned to indicate that the callback may have been called already by the alarm, but it is not guaranteed, so the
            /// caller should also call the callback, just like in the more common `false` case. (Note: This requires idempotency of the callback.)
            ///
            /// When callback is called, it is guaranteed that now() will return a value greater or equal than timestamp.
            ///
            /// Only one alarm can be active at a time for each AlarmHandle. This overwrites any previously-set alarm if any.
            fn set_alarm(&self, alarm: AlarmHandle, timestamp: INT64U) -> BOOLEAN;
        }
        unsafe impl Send for AlarmState {}
        impl AlarmState {
            const fn new() -> Self {
                Self {
                    timestamp: Cell::new(INT64U::MAX),
                    callback: Cell::new(ptr::null()),
                    ctx: Cell::new(ptr::null_mut()),
                }
            }
        }
        impl AlarmHandle {
            /// Create an AlarmHandle
            ///
            /// Safety: May only be called by the current global Driver impl.
            /// The impl is allowed to rely on the fact that all `AlarmHandle` instances
            /// are created by itself in unsafe code (e.g. indexing operations)
            pub unsafe fn new(id: u8) -> Self {
                Self { id }
            }
            /// Get the ID of the AlarmHandle.
            pub fn id(&self) -> u8 {
                self.id
            }
        }
        impl RtcDriver {
            pub(crate) fn init(&'static self) {
                rcc_init();
                enable_Timer();
                TIMER.cr1().modify(|w| w.set_cen(false));
                TIMER.cnt().write(|w| w.set_cnt(0));
                let psc = (APB_HZ / TICK_HZ) as INT32U - 1;
                let psc: INT16U = match psc.try_into() {
                    Err(_) => {
                        ::core::panicking::panic_fmt(
                            format_args!("psc division overflow: {0}", psc),
                        );
                    }
                    Ok(n) => n,
                };
                TIMER.psc().write_value(psc);
                TIMER.arr().write(|w| w.set_arr(INT16U::MAX));
                TIMER.cr1().modify(|w| w.set_urs(vals::Urs::COUNTERONLY));
                TIMER.egr().write(|w| w.set_ug(true));
                TIMER.cr1().modify(|w| w.set_urs(vals::Urs::ANYEVENT));
                TIMER.ccr(0).write(|w| w.set_ccr(0x8000));
                TIMER
                    .dier()
                    .write(|w| {
                        w.set_uie(true);
                        w.set_ccie(0, true);
                    });
                #[cfg(feature = "time_driver_tim3")] NVIC::unpend(Interrupt::TIM3);
                #[cfg(feature = "time_driver_tim3")]
                unsafe {
                    compiler_fence(Ordering::SeqCst);
                    NVIC::unmask(Interrupt::TIM3);
                }
                TIMER.cr1().modify(|w| w.set_cen(ENABLE));
            }
            fn on_interrupt(&self) {
                critical_section::with(|cs| {
                    let sr = TIMER.sr().read();
                    let dier = TIMER.dier().read();
                    TIMER.sr().write_value(regs::SrGp16(!sr.0));
                    if sr.uif() {
                        self.next_period();
                    }
                    if sr.ccif(0) {
                        self.next_period();
                    }
                    for n in 0..ALARM_COUNT {
                        if sr.ccif(n + 1) && dier.ccie(n + 1) {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path = "ucosii::port::time_driver".as_bytes();
                                                if if 6usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                        && module_path[2usize] == 111u8
                                                        && module_path[3usize] == 115u8
                                                        && module_path[4usize] == 105u8
                                                        && module_path[5usize] == 105u8
                                                        && if 6usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[6usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe { defmt::export::acquire() };
                                        defmt::export::header(
                                            &{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the alarm is triggered!!!\",\"disambiguator\":\"1695760017282031468\",\"crate_name\":\"ucosii\"}"]
                                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the alarm is triggered!!!\",\"disambiguator\":\"1695760017282031468\",\"crate_name\":\"ucosii\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            },
                                        );
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            self.trigger_alarm(n, cs);
                        }
                    }
                })
            }
            fn next_period(&self) {
                let period = self.period.load(Ordering::Relaxed) + 1;
                self.period.store(period, Ordering::Relaxed);
                let t = (period as u64) << 15;
                critical_section::with(move |cs| {
                    TIMER
                        .dier()
                        .modify(move |w| {
                            for n in 0..ALARM_COUNT {
                                let alarm = &self.alarms.borrow(cs)[n];
                                let at = alarm.timestamp.get();
                                if at < t + 0xc000 {
                                    w.set_ccie(n + 1, true);
                                }
                            }
                        })
                })
            }
            fn get_alarm<'a>(
                &'a self,
                cs: CriticalSection<'a>,
                alarm: AlarmHandle,
            ) -> &'a AlarmState {
                unsafe { self.alarms.borrow(cs).get_unchecked(alarm.id() as usize) }
            }
            fn trigger_alarm(&self, n: usize, cs: CriticalSection) {
                let alarm = &self.alarms.borrow(cs)[n];
                alarm.timestamp.set(u64::MAX);
                let f: fn(*mut ()) = unsafe { mem::transmute(alarm.callback.get()) };
                f(alarm.ctx.get());
            }
        }
        impl Driver for RtcDriver {
            fn now(&self) -> u64 {
                let period = self.period.load(Ordering::Relaxed);
                compiler_fence(Ordering::Acquire);
                let counter = TIMER.cnt().read().cnt();
                calc_now(period, counter)
            }
            unsafe fn allocate_alarm(&self) -> Option<AlarmHandle> {
                critical_section::with(|_| {
                    let id = self.alarm_count.load(Ordering::Relaxed);
                    if id < ALARM_COUNT as u8 {
                        self.alarm_count.store(id + 1, Ordering::Relaxed);
                        Some(AlarmHandle::new(id))
                    } else {
                        None
                    }
                })
            }
            fn set_alarm_callback(
                &self,
                alarm: AlarmHandle,
                callback: fn(*mut ()),
                ctx: *mut (),
            ) {
                critical_section::with(|cs| {
                    let alarm = self.get_alarm(cs, alarm);
                    alarm.callback.set(callback as *const ());
                    alarm.ctx.set(ctx);
                })
            }
            fn set_alarm(&self, alarm: AlarmHandle, timestamp: INT64U) -> bool {
                match () {
                    () => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::port::time_driver".as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"set the alarm\",\"disambiguator\":\"15443444190568624020\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"set the alarm\",\"disambiguator\":\"15443444190568624020\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let n = alarm.id() as usize;
                if timestamp == INT64U::MAX {
                    critical_section::with(|cs| {
                        let alarm = self.get_alarm(cs, alarm);
                        alarm.timestamp.set(u64::MAX);
                        TIMER.dier().modify(|w| w.set_ccie(n + 1, false));
                    });
                    return true;
                }
                critical_section::with(|cs| {
                    let alarm = self.get_alarm(cs, alarm);
                    alarm.timestamp.set(timestamp);
                    let t = self.now();
                    if timestamp <= t {
                        TIMER.dier().modify(|w| w.set_ccie(n + 1, false));
                        alarm.timestamp.set(u64::MAX);
                        return false;
                    }
                    TIMER.ccr(n + 1).write(|w| w.set_ccr(timestamp as u16));
                    let diff = timestamp - t;
                    TIMER.dier().modify(|w| w.set_ccie(n + 1, diff < 0xc000));
                    let t = self.now();
                    if timestamp <= t {
                        TIMER.dier().modify(|w| w.set_ccie(n + 1, false));
                        alarm.timestamp.set(u64::MAX);
                        return false;
                    }
                    true
                })
            }
        }
        #[allow(clippy::declare_interior_mutable_const)]
        const ALARM_STATE_NEW: AlarmState = AlarmState::new();
        /// the global RTC driver
        pub(crate) static RTC_DRIVER: RtcDriver = RtcDriver {
            period: AtomicU32::new(0),
            alarm_count: AtomicU8::new(0),
            alarms: Mutex::new([ALARM_STATE_NEW; ALARM_COUNT]),
        };
        /// set the rcc of the Timer
        pub fn rcc_init() {
            RCC.cr()
                .modify(|v| {
                    v.set_pllon(DISABLE);
                    v.set_plli2son(DISABLE);
                });
            RCC.pllcfgr()
                .modify(|v| {
                    v.set_pllm(Pllm::DIV4);
                    v.set_plln(Plln::MUL84);
                    v.set_pllp(Pllp::DIV2);
                    v.set_pllq(Pllq::DIV4);
                    v.set_pllsrc(Pllsrc::HSE);
                });
            RCC.cfgr()
                .modify(|v| {
                    v.set_hpre(Hpre::DIV1);
                    v.set_ppre1(Ppre::DIV2);
                    v.set_ppre2(Ppre::DIV1);
                });
            RCC.cr()
                .modify(|v| {
                    v.set_hseon(ENABLE);
                    v.set_pllon(ENABLE);
                    v.set_plli2son(ENABLE);
                });
            while !RCC.cr().read().hserdy() || !RCC.cr().read().pllrdy()
                || !RCC.cr().read().plli2srdy()
            {}
            FLASH.acr().modify(|v| v.set_prften(ENABLE));
            FLASH.acr().modify(|v| v.set_latency(Latency::WS2));
            RCC.cfgr().modify(|v| v.set_sw(Sw::PLL1_P));
            RCC.cr().modify(|v| v.set_hsion(DISABLE));
        }
        fn enable_Timer() {
            #[cfg(feature = "time_driver_tim3")]
            RCC.apb1enr().modify(|v| v.set_tim3en(ENABLE));
        }
        fn calc_now(period: INT32U, counter: INT16U) -> INT64U {
            ((period as INT64U) << 15) + ((counter as u32 ^ ((period & 1) << 15)) as u64)
        }
        #[no_mangle]
        /// Schedule the given waker to be woken at `at`.
        pub fn _embassy_time_schedule_wake(at: u64, waker: &core::task::Waker) {
            let task = waker::task_from_waker(waker);
            let task = task.header();
            unsafe {
                let expires_at = task.expires_at.get();
                task.expires_at.set(expires_at.min(at));
            }
        }
    }
}
/// the mod which define the data structure of uC/OS-II kernel
pub mod ucosii {
    use core::cell::RefCell;
    use core::sync::atomic::{AtomicBool, AtomicU32, AtomicU8};
    use critical_section::Mutex;
    use lazy_static::lazy_static;
    use crate::cfg::*;
    use crate::executor::OS_TCB_REF;
    use crate::port::*;
    #[allow(unused)]
    const OS_PRIO_SELF: INT32U = 0xFF;
    #[allow(unused)]
    const OS_PRIO_MUTEX_CEIL_DIS: INT32U = 0xFF;
    #[cfg(not(feature = "OS_TASK_STAT_EN"))]
    #[allow(unused)]
    /// Number of system tasks
    pub const OS_N_SYS_TASKS: USIZE = 0;
    #[allow(unused)]
    pub(crate) const OS_TASK_STAT_PRIO: OS_PRIO = OS_LOWEST_PRIO - 1;
    #[allow(unused)]
    pub(crate) const OS_TASK_IDLE_PRIO: OS_PRIO = OS_LOWEST_PRIO;
    #[cfg(feature = "OS_PRIO_LESS_THAN_64")]
    const OS_EVENT_TBL_SIZE: USIZE = (OS_LOWEST_PRIO / 8 + 1) as USIZE;
    /// Size of ready table
    #[allow(unused)]
    pub const OS_RDY_TBL_SIZE: USIZE = OS_EVENT_TBL_SIZE;
    #[allow(unused)]
    const OS_TASK_IDLE_ID: INT32U = 65535;
    #[allow(unused)]
    const OS_TASK_STAT_ID: INT32U = 65534;
    #[allow(unused)]
    const OS_TASK_TMR_ID: INT32U = 65533;
    #[allow(unused)]
    const OS_VERSION: INT32U = 29300;
    #[allow(unused)]
    const OS_STAT_RDY: INT32U = 0x00;
    #[allow(unused)]
    const OS_STAT_SEM: INT32U = 0x01;
    #[allow(unused)]
    const OS_STAT_MBOX: INT32U = 0x02;
    #[allow(unused)]
    const OS_STAT_Q: INT32U = 0x04;
    #[allow(unused)]
    const OS_STAT_SUSPEND: INT32U = 0x08;
    #[allow(unused)]
    const OS_STAT_MUTEX: INT32U = 0x10;
    #[allow(unused)]
    const OS_STAT_FLAG: INT32U = 0x20;
    #[allow(unused)]
    const OS_STAT_MULTI: INT32U = 0x80;
    #[allow(unused)]
    const OS_STAT_PEND_ANY: INT32U = (OS_STAT_SEM | OS_STAT_MBOX | OS_STAT_Q
        | OS_STAT_MUTEX | OS_STAT_FLAG);
    #[allow(unused)]
    const OS_STAT_PEND_OK: INT32U = 0;
    #[allow(unused)]
    const OS_STAT_PEND_TO: INT32U = 1;
    #[allow(unused)]
    const OS_STAT_PEND_ABORT: INT32U = 2;
    #[allow(unused)]
    const OS_EVENT_TYPE_UNUSED: INT32U = 0;
    #[allow(unused)]
    const OS_EVENT_TYPE_MBOX: INT32U = 1;
    #[allow(unused)]
    const OS_EVENT_TYPE_Q: INT32U = 2;
    #[allow(unused)]
    const OS_EVENT_TYPE_SEM: INT32U = 3;
    #[allow(unused)]
    const OS_EVENT_TYPE_MUTEX: INT32U = 4;
    #[allow(unused)]
    const OS_EVENT_TYPE_FLAG: INT32U = 5;
    #[allow(unused)]
    const OS_TMR_TYPE: INT32U = 100;
    #[allow(unused)]
    const OS_FLAG_WAIT_CLR_ALL: INT32U = 0;
    #[allow(unused)]
    const OS_FLAG_WAIT_CLR_AND: INT32U = 0;
    #[allow(unused)]
    const OS_FLAG_WAIT_CLR_ANY: INT32U = 1;
    #[allow(unused)]
    const OS_FLAG_WAIT_CLR_OR: INT32U = 1;
    #[allow(unused)]
    const OS_FLAG_WAIT_SET_ALL: INT32U = 2;
    #[allow(unused)]
    const OS_FLAG_WAIT_SET_AND: INT32U = 2;
    #[allow(unused)]
    const OS_FLAG_WAIT_SET_ANY: INT32U = 3;
    #[allow(unused)]
    const OS_FLAG_WAIT_SET_OR: INT32U = 3;
    #[allow(unused)]
    const OS_FLAG_CONSUME: INT32U = 0x80;
    #[allow(unused)]
    const OS_FLAG_CLR: INT32U = 0;
    #[allow(unused)]
    const OS_FLAG_SET: INT32U = 1;
    #[allow(unused)]
    const OS_DEL_NO_PEND: INT32U = 0;
    #[allow(unused)]
    const OS_DEL_ALWAYS: INT32U = 1;
    #[allow(unused)]
    const OS_PEND_OPT_NONE: INT32U = 0;
    #[allow(unused)]
    const OS_PEND_OPT_BROADCAST: INT32U = 1;
    #[allow(unused)]
    const OS_POST_OPT_NONE: INT32U = 0x00;
    #[allow(unused)]
    const OS_POST_OPT_BROADCAST: INT32U = 0x01;
    #[allow(unused)]
    const OS_POST_OPT_FRONT: INT32U = 0x02;
    #[allow(unused)]
    const OS_POST_OPT_NO_SCHED: INT32U = 0x04;
    #[allow(unused)]
    const OS_TASK_OPT_NONE: INT32U = 0x0000;
    #[allow(unused)]
    const OS_TASK_OPT_STK_CHK: INT32U = 0x0001;
    #[allow(unused)]
    const OS_TASK_OPT_STK_CLR: INT32U = 0x0002;
    #[allow(unused)]
    const OS_TASK_OPT_SAVE_FP: INT32U = 0x0004;
    #[allow(unused)]
    const OS_TASK_OPT_NO_TLS: INT32U = 0x0008;
    #[allow(unused)]
    const OS_TMR_OPT_NONE: INT32U = 0;
    #[allow(unused)]
    const OS_TMR_OPT_ONE_SHOT: INT32U = 1;
    #[allow(unused)]
    const OS_TMR_OPT_PERIODIC: INT32U = 2;
    #[allow(unused)]
    const OS_TMR_OPT_CALLBACK: INT32U = 3;
    #[allow(unused)]
    const OS_TMR_OPT_CALLBACK_ARG: INT32U = 4;
    #[allow(unused)]
    const OS_TMR_STATE_UNUSED: INT32U = 0;
    #[allow(unused)]
    const OS_TMR_STATE_STOPPED: INT32U = 1;
    #[allow(unused)]
    const OS_TMR_STATE_COMPLETED: INT32U = 2;
    #[allow(unused)]
    const OS_TMR_STATE_RUNNING: INT32U = 3;
    #[repr(align(8))]
    /// uC/OS-II error codes
    pub enum OS_ERR_STATE {
        /// No error
        OS_ERR_NONE,
        /// The event type is invalid
        OS_ERR_EVENT_TYPE,
        /// The task is pending due to an interrupt service routine (ISR).
        OS_ERR_PEND_ISR,
        /// The pointer to post is NULL
        OS_ERR_POST_NULL_PTR,
        /// The event pointer is NULL
        OS_ERR_PEVENT_NULL,
        /// The post operation was called from an ISR
        OS_ERR_POST_ISR,
        /// The query operation was called from an ISR
        OS_ERR_QUERY_ISR,
        /// The option is invalid
        OS_ERR_INVALID_OPT,
        /// The ID is invalid
        OS_ERR_ID_INVALID,
        /// The pointer to data is NULL
        OS_ERR_PDATA_NULL,
        /// The operation timed out
        OS_ERR_TIMEOUT,
        /// The event name is too long
        OS_ERR_EVENT_NAME_TOO_LONG,
        /// The pointer to name is NULL
        OS_ERR_PNAME_NULL,
        /// The pend operation is locked
        OS_ERR_PEND_LOCKED,
        /// The pend operation was aborted
        OS_ERR_PEND_ABORT,
        /// The delete operation was called from an ISR
        OS_ERR_DEL_ISR,
        /// The create operation was called from an ISR
        OS_ERR_CREATE_ISR,
        /// The get name operation was called from an ISR
        OS_ERR_NAME_GET_ISR,
        /// The set name operation was called from an ISR
        OS_ERR_NAME_SET_ISR,
        /// The create operation is illegal at runtime
        OS_ERR_ILLEGAL_CREATE_RUN_TIME,
        /// The mailbox is full
        OS_ERR_MBOX_FULL,
        /// The delete operation is illegal at runtime
        OS_ERR_ILLEGAL_DEL_RUN_TIME,
        /// The queue is full
        OS_ERR_Q_FULL,
        /// The queue is empty
        OS_ERR_Q_EMPTY,
        /// The priority already exists
        OS_ERR_PRIO_EXIST,
        /// The priority is invalid
        OS_ERR_PRIO,
        /// The priority is invalid
        OS_ERR_PRIO_INVALID,
        /// The scheduler is locked
        OS_ERR_SCHED_LOCKED,
        /// The semaphore overflowed
        OS_ERR_SEM_OVF,
        /// The task create operation was called from an ISR
        OS_ERR_TASK_CREATE_ISR,
        /// The task delete operation failed
        OS_ERR_TASK_DEL,
        /// The task delete operation failed because the task is idle
        OS_ERR_TASK_DEL_IDLE,
        /// The task delete operation was requested
        OS_ERR_TASK_DEL_REQ,
        /// The task delete operation was called from an ISR
        OS_ERR_TASK_DEL_ISR,
        /// The task name is too long
        OS_ERR_TASK_NAME_TOO_LONG,
        /// No more TCBs are available
        OS_ERR_TASK_NO_MORE_TCB,
        /// The task does not exist
        OS_ERR_TASK_NOT_EXIST,
        /// The task is not suspended
        OS_ERR_TASK_NOT_SUSPENDED,
        /// The task option is invalid
        OS_ERR_TASK_OPT,
        /// The task resume priority is invalid
        OS_ERR_TASK_RESUME_PRIO,
        /// The task suspend operation failed because the task is idle
        OS_ERR_TASK_SUSPEND_IDLE,
        /// The task suspend operation failed because the priority is invalid
        OS_ERR_TASK_SUSPEND_PRIO,
        /// The task is waiting
        OS_ERR_TASK_WAITING,
        /// The time is not a delay
        OS_ERR_TIME_NOT_DLY,
        /// The minutes are invalid
        OS_ERR_TIME_INVALID_MINUTES,
        /// The seconds are invalid
        OS_ERR_TIME_INVALID_SECONDS,
        /// The milliseconds are invalid
        OS_ERR_TIME_INVALID_MS,
        /// The delay is zero
        OS_ERR_TIME_ZERO_DLY,
        /// The delay operation was called from an ISR
        OS_ERR_TIME_DLY_ISR,
        /// The memory partition is invalid
        OS_ERR_MEM_INVALID_PART,
        /// The memory block size is invalid
        OS_ERR_MEM_INVALID_BLKS,
        /// The memory size is invalid
        OS_ERR_MEM_INVALID_SIZE,
        /// There are no free memory blocks
        OS_ERR_MEM_NO_FREE_BLKS,
        /// The memory is full
        OS_ERR_MEM_FULL,
        /// The memory partition block is invalid
        OS_ERR_MEM_INVALID_PBLK,
        /// The memory partition memory is invalid
        OS_ERR_MEM_INVALID_PMEM,
        /// The memory partition data is invalid
        OS_ERR_MEM_INVALID_PDATA,
        /// The memory address is invalid
        OS_ERR_MEM_INVALID_ADDR,
        /// The memory name is too long
        OS_ERR_MEM_NAME_TOO_LONG,
        /// The task is not the mutex owner
        OS_ERR_NOT_MUTEX_OWNER,
        /// The flag group is invalid
        OS_ERR_FLAG_INVALID_PGRP,
        /// The flag wait type is invalid
        OS_ERR_FLAG_WAIT_TYPE,
        /// The flag is not ready
        OS_ERR_FLAG_NOT_RDY,
        /// The flag option is invalid
        OS_ERR_FLAG_INVALID_OPT,
        /// The flag group is depleted
        OS_ERR_FLAG_GRP_DEPLETED,
        /// The flag name is too long
        OS_ERR_FLAG_NAME_TOO_LONG,
        /// The PCP is lower than the current PCP
        OS_ERR_PCP_LOWER,
        /// The timer delay is invalid
        OS_ERR_TMR_INVALID_DLY,
        /// The timer period is invalid
        OS_ERR_TMR_INVALID_PERIOD,
        /// The timer option is invalid
        OS_ERR_TMR_INVALID_OPT,
        /// The timer name is invalid
        OS_ERR_TMR_INVALID_NAME,
        /// The timer is not available
        OS_ERR_TMR_NON_AVAIL,
        /// The timer is inactive
        OS_ERR_TMR_INACTIVE,
        /// The timer destination is invalid
        OS_ERR_TMR_INVALID_DEST,
        /// The timer type is invalid
        OS_ERR_TMR_INVALID_TYPE,
        /// The timer is invalid
        OS_ERR_TMR_INVALID,
        /// The timer operation was called from an ISR
        OS_ERR_TMR_ISR,
        /// The timer name is too long
        OS_ERR_TMR_NAME_TOO_LONG,
        /// The timer state is invalid
        OS_ERR_TMR_INVALID_STATE,
        /// The timer is stopped
        OS_ERR_TMR_STOPPED,
        /// The timer has no callback function
        OS_ERR_TMR_NO_CALLBACK,
        /// No more IDs are available
        OS_ERR_NO_MORE_ID_AVAIL,
        /// No more TLS slots are available
        OS_ERR_TLS_NO_MORE_AVAIL,
        /// The TLS ID is invalid
        OS_ERR_TLS_ID_INVALID,
        /// The TLS is not enabled
        OS_ERR_TLS_NOT_EN,
        /// The TLS destructor is already assigned
        OS_ERR_TLS_DESTRUCT_ASSIGNED,
        /// The operating system is not running
        OS_ERR_OS_NOT_RUNNING,
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OS_ERR_STATE {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OS_ERR_STATE {
        #[inline]
        fn eq(&self, other: &OS_ERR_STATE) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    /// the prio type defination in the rust-uC
    #[cfg(feature = "OS_PRIO_LESS_THAN_64")]
    #[allow(non_camel_case_types)]
    pub type OS_PRIO = u8;
    /// the data of the os mem part
    #[allow(unused)]
    pub struct OS_MEM_DATA {
        OSAddr: PTR,
        OSFreeList: PTR,
        OSBlkSize: INT32U,
        OSNBlks: INT32U,
        OSNFree: INT32U,
        OSNUsed: INT32U,
    }
    /// the data of the OS stk
    #[cfg(feature = "OS_TASK_CREATE_EXT_EN")]
    #[allow(unused)]
    pub struct OS_STK_DATA {
        OSFree: INT32U,
        OSUsed: INT32U,
    }
    /// Current value of system time (in ticks)
    #[cfg(feature = "OS_TIME_GET_SET_EN")]
    pub static OSTime: AtomicU32 = AtomicU32::new(0);
    /// Interrupt nesting level
    pub static OSIntNesting: AtomicU8 = AtomicU8::new(0);
    /// Multitasking lock nesting level
    pub static OSLockNesting: AtomicU8 = AtomicU8::new(0);
    /// Number of tasks created
    pub static OSTaskCtr: AtomicU8 = AtomicU8::new(0);
    /// Flag indicating that kernel is running
    pub static OSRunning: AtomicBool = AtomicBool::new(false);
    /// Counter of number of context switches
    pub static OSCtxSwCtr: AtomicU32 = AtomicU32::new(0);
    /// Idle counter
    pub static OSIdleCtr: AtomicU32 = AtomicU32::new(0);
    /// Next available Task register ID
    #[cfg(feature = "OS_TASK_REG_TBL_SIZE")]
    pub static OSTaskRegNextAvailID: AtomicU8 = AtomicU8::new(0);
    /// by noah: the ref of Table of TCBs. TCBs will be stored in Arena in executor.rs
    /// Priority of highest priority task
    pub static OSPrioHighRdy: AtomicU8 = AtomicU8::new(0);
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    /// we need the lazy static so that we can call default to get the default value
    /// Pointer to currently running TCB
    pub struct OSTCBCur {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static OSTCBCur: OSTCBCur = OSTCBCur { __private_field: () };
    impl ::lazy_static::__Deref for OSTCBCur {
        type Target = Mutex<RefCell<OS_TCB_REF>>;
        fn deref(&self) -> &Mutex<RefCell<OS_TCB_REF>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<RefCell<OS_TCB_REF>> {
                Mutex::new(RefCell::new(OS_TCB_REF::default()))
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<RefCell<OS_TCB_REF>> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<RefCell<OS_TCB_REF>>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for OSTCBCur {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    /// Pointer to highest priority TCB R-to-R
    pub struct OSTCBHighRdy {
        __private_field: (),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals)]
    pub static OSTCBHighRdy: OSTCBHighRdy = OSTCBHighRdy {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for OSTCBHighRdy {
        type Target = Mutex<RefCell<OS_TCB_REF>>;
        fn deref(&self) -> &Mutex<RefCell<OS_TCB_REF>> {
            #[inline(always)]
            fn __static_ref_initialize() -> Mutex<RefCell<OS_TCB_REF>> {
                Mutex::new(RefCell::new(OS_TCB_REF::default()))
            }
            #[inline(always)]
            fn __stability() -> &'static Mutex<RefCell<OS_TCB_REF>> {
                static LAZY: ::lazy_static::lazy::Lazy<Mutex<RefCell<OS_TCB_REF>>> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for OSTCBHighRdy {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
}
/// the the macro of atomic operation
#[macro_use]
/// the atomic_macros module is used to define atomic operations
pub mod atomic_macros {}
mod heap {
    pub mod fixed_size_block {
        use alloc::alloc::{GlobalAlloc, Layout};
        use defmt::info;
        use core::mem;
        use core::ptr::{self, NonNull};
        use super::linked_list::Heap;
        use super::Locked;
        /// The block sizes to use.
        ///
        /// The sizes must each be power of 2 because they are also used as
        /// the block alignment (alignments must be always powers of 2).
        const BLOCK_SIZES: &[usize] = &[128, 256, 512, 1024, 2048, 4096, 8192, 16384];
        /// Choose an appropriate block size for the given layout.
        ///
        /// Returns an index into the `BLOCK_SIZES` array.
        fn list_index(layout: &Layout) -> Option<usize> {
            let required_block_size = layout.size().max(layout.align());
            BLOCK_SIZES.iter().position(|&s| s >= required_block_size)
        }
        struct ListNode {
            next: Option<&'static mut ListNode>,
        }
        pub struct FixedSizeBlockAllocator {
            list_heads: [Option<&'static mut ListNode>; BLOCK_SIZES.len()],
            fallback_allocator: Heap,
        }
        impl FixedSizeBlockAllocator {
            /// Creates an empty FixedSizeBlockAllocator.
            pub const fn new() -> Self {
                const EMPTY: Option<&'static mut ListNode> = None;
                FixedSizeBlockAllocator {
                    list_heads: [EMPTY; BLOCK_SIZES.len()],
                    fallback_allocator: Heap::empty(),
                }
            }
            /// Initialize the allocator with the given heap bounds.
            ///
            /// This function is unsafe because the caller must guarantee that the given
            /// heap bounds are valid and that the heap is unused. This method must be
            /// called only once.
            pub unsafe fn init(&mut self, heap_start: *mut u8, heap_size: usize) {
                self.fallback_allocator.init(heap_start, heap_size);
            }
            /// Allocates using the fallback allocator.
            fn fallback_alloc(&mut self, layout: Layout) -> *mut u8 {
                match self.fallback_allocator.allocate_first_fit(layout) {
                    Ok(ptr) => ptr.as_ptr(),
                    Err(err) => {
                        match (&(err)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path = "ucosii::heap::fixed_size_block"
                                                .as_bytes();
                                            if if 6usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                    && module_path[2usize] == 111u8
                                                    && module_path[3usize] == 115u8
                                                    && module_path[4usize] == 105u8
                                                    && module_path[5usize] == 105u8
                                                    && if 6usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[6usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe { defmt::export::acquire() };
                                    defmt::export::header(
                                        &{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"fallback allocator failed: {:?}\",\"disambiguator\":\"8863529737627275544\",\"crate_name\":\"ucosii\"}"]
                                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"fallback allocator failed: {:?}\",\"disambiguator\":\"8863529737627275544\",\"crate_name\":\"ucosii\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        },
                                    );
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        ptr::null_mut()
                    }
                }
            }
        }
        unsafe impl GlobalAlloc for Locked<FixedSizeBlockAllocator> {
            unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
                let mut allocator = self.lock();
                match list_index(&layout) {
                    Some(index) => {
                        match allocator.list_heads[index].take() {
                            Some(node) => {
                                allocator.list_heads[index] = node.next.take();
                                node as *mut ListNode as *mut u8
                            }
                            None => {
                                let block_size = BLOCK_SIZES[index];
                                let block_align = block_size;
                                let layout = Layout::from_size_align(
                                        block_size,
                                        block_align,
                                    )
                                    .unwrap();
                                let ptr = allocator.fallback_alloc(layout);
                                match (&(block_size), &(ptr)) {
                                    (arg0, arg1) => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path = "ucosii::heap::fixed_size_block"
                                                        .as_bytes();
                                                    if if 6usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                            && module_path[2usize] == 111u8
                                                            && module_path[3usize] == 115u8
                                                            && module_path[4usize] == 105u8
                                                            && module_path[5usize] == 105u8
                                                            && if 6usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[6usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe { defmt::export::acquire() };
                                            defmt::export::header(
                                                &{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"allocating block of size {} at {}\",\"disambiguator\":\"16513472078444673418\",\"crate_name\":\"ucosii\"}"]
                                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"allocating block of size {} at {}\",\"disambiguator\":\"16513472078444673418\",\"crate_name\":\"ucosii\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                },
                                            );
                                            defmt::export::fmt(arg0);
                                            defmt::export::fmt(arg1);
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                ptr
                            }
                        }
                    }
                    None => allocator.fallback_alloc(layout),
                }
            }
            unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
                match (&(layout.size()), &(ptr)) {
                    (arg0, arg1) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::heap::fixed_size_block"
                                        .as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"deallocating block of size {} at {}\",\"disambiguator\":\"13725042102103814386\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"deallocating block of size {} at {}\",\"disambiguator\":\"13725042102103814386\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            defmt::export::fmt(arg1);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let mut allocator = self.lock();
                match list_index(&layout) {
                    Some(index) => {
                        let new_node = ListNode {
                            next: allocator.list_heads[index].take(),
                        };
                        if !(mem::size_of::<ListNode>() <= BLOCK_SIZES[index]) {
                            ::core::panicking::panic(
                                "assertion failed: mem::size_of::<ListNode>() <= BLOCK_SIZES[index]",
                            )
                        }
                        if !(mem::align_of::<ListNode>() <= BLOCK_SIZES[index]) {
                            ::core::panicking::panic(
                                "assertion failed: mem::align_of::<ListNode>() <= BLOCK_SIZES[index]",
                            )
                        }
                        let new_node_ptr = ptr as *mut ListNode;
                        new_node_ptr.write(new_node);
                        allocator.list_heads[index] = Some(&mut *new_node_ptr);
                    }
                    None => {
                        let ptr = NonNull::new(ptr).unwrap();
                        allocator.fallback_allocator.deallocate(ptr, layout);
                    }
                }
            }
        }
    }
    pub mod linked_list {
        #[cfg(feature = "use_spin")]
        extern crate spinning_top;
        #[cfg(feature = "use_spin")]
        use core::alloc::GlobalAlloc;
        use core::alloc::Layout;
        use core::mem::MaybeUninit;
        #[cfg(feature = "use_spin")]
        use core::ops::Deref;
        use core::ptr::NonNull;
        use hole::HoleList;
        #[cfg(feature = "use_spin")]
        use spinning_top::Spinlock;
        pub mod hole {
            use core::alloc::{Layout, LayoutError};
            use core::mem;
            use core::mem::{align_of, size_of};
            use core::ptr::null_mut;
            use core::ptr::NonNull;
            use defmt::info;
            use super::{align_down_size, align_up_size};
            use super::align_up;
            /// A sorted list of holes. It uses the the holes itself to store its nodes.
            pub struct HoleList {
                pub(crate) first: Hole,
                pub(crate) bottom: *mut u8,
                pub(crate) top: *mut u8,
                pub(crate) pending_extend: u8,
            }
            pub(crate) struct Cursor {
                prev: NonNull<Hole>,
                hole: NonNull<Hole>,
                top: *mut u8,
            }
            /// A block containing free memory. It points to the next hole and thus forms a linked list.
            pub(crate) struct Hole {
                pub size: usize,
                pub next: Option<NonNull<Hole>>,
            }
            /// Basic information about a hole.
            struct HoleInfo {
                addr: *mut u8,
                size: usize,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for HoleInfo {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "HoleInfo",
                        "addr",
                        &self.addr,
                        "size",
                        &&self.size,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for HoleInfo {
                #[inline]
                fn clone(&self) -> HoleInfo {
                    let _: ::core::clone::AssertParamIsClone<*mut u8>;
                    let _: ::core::clone::AssertParamIsClone<usize>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for HoleInfo {}
            impl Cursor {
                fn next(mut self) -> Option<Self> {
                    match () {
                        () => {
                            if {
                                const CHECK: bool = {
                                    const fn check() -> bool {
                                        let module_path = "ucosii::heap::linked_list::hole"
                                            .as_bytes();
                                        if if 6usize > module_path.len() {
                                            false
                                        } else {
                                            module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                && module_path[2usize] == 111u8
                                                && module_path[3usize] == 115u8
                                                && module_path[4usize] == 105u8
                                                && module_path[5usize] == 105u8
                                                && if 6usize == module_path.len() {
                                                    true
                                                } else {
                                                    module_path[6usize] == b':'
                                                }
                                        } {
                                            return true;
                                        }
                                        false
                                    }
                                    check()
                                };
                                CHECK
                            } {
                                unsafe { defmt::export::acquire() };
                                defmt::export::header(
                                    &{
                                        defmt::export::make_istr({
                                            #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"call cursor next\",\"disambiguator\":\"17827488732848052693\",\"crate_name\":\"ucosii\"}"]
                                            #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"call cursor next\",\"disambiguator\":\"17827488732848052693\",\"crate_name\":\"ucosii\"}"]
                                            static DEFMT_LOG_STATEMENT: u8 = 0;
                                            &DEFMT_LOG_STATEMENT as *const u8 as u16
                                        })
                                    },
                                );
                                unsafe { defmt::export::release() }
                            }
                        }
                    };
                    unsafe {
                        match (&(self.hole.as_ref().next)) {
                            (arg0) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path = "ucosii::heap::linked_list::hole"
                                                .as_bytes();
                                            if if 6usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                    && module_path[2usize] == 111u8
                                                    && module_path[3usize] == 115u8
                                                    && module_path[4usize] == 105u8
                                                    && module_path[5usize] == 105u8
                                                    && if 6usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[6usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe { defmt::export::acquire() };
                                    defmt::export::header(
                                        &{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the next is:{}\",\"disambiguator\":\"7247784460779400609\",\"crate_name\":\"ucosii\"}"]
                                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the next is:{}\",\"disambiguator\":\"7247784460779400609\",\"crate_name\":\"ucosii\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        },
                                    );
                                    defmt::export::fmt(arg0);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        self.hole
                            .as_mut()
                            .next
                            .map(|nhole| Cursor {
                                prev: self.hole,
                                hole: nhole,
                                top: self.top,
                            })
                    }
                }
                fn current(&self) -> &Hole {
                    unsafe { self.hole.as_ref() }
                }
                fn previous(&self) -> &Hole {
                    unsafe { self.prev.as_ref() }
                }
                fn split_current(
                    self,
                    required_layout: Layout,
                ) -> Result<(*mut u8, usize), Self> {
                    let front_padding;
                    let alloc_ptr;
                    let alloc_size;
                    let back_padding;
                    {
                        let hole_size = self.current().size;
                        let hole_addr_u8 = self.hole.as_ptr().cast::<u8>();
                        let required_size = required_layout.size();
                        let required_align = required_layout.align();
                        match (&(hole_size), &(hole_addr_u8)) {
                            (arg0, arg1) => {
                                if {
                                    const CHECK: bool = {
                                        const fn check() -> bool {
                                            let module_path = "ucosii::heap::linked_list::hole"
                                                .as_bytes();
                                            if if 6usize > module_path.len() {
                                                false
                                            } else {
                                                module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                    && module_path[2usize] == 111u8
                                                    && module_path[3usize] == 115u8
                                                    && module_path[4usize] == 105u8
                                                    && module_path[5usize] == 105u8
                                                    && if 6usize == module_path.len() {
                                                        true
                                                    } else {
                                                        module_path[6usize] == b':'
                                                    }
                                            } {
                                                return true;
                                            }
                                            false
                                        }
                                        check()
                                    };
                                    CHECK
                                } {
                                    unsafe { defmt::export::acquire() };
                                    defmt::export::header(
                                        &{
                                            defmt::export::make_istr({
                                                #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the cur hole_size is:{} and the cur hole_addr_u8 is:{}\",\"disambiguator\":\"893437474549435881\",\"crate_name\":\"ucosii\"}"]
                                                #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the cur hole_size is:{} and the cur hole_addr_u8 is:{}\",\"disambiguator\":\"893437474549435881\",\"crate_name\":\"ucosii\"}"]
                                                static DEFMT_LOG_STATEMENT: u8 = 0;
                                                &DEFMT_LOG_STATEMENT as *const u8 as u16
                                            })
                                        },
                                    );
                                    defmt::export::fmt(arg0);
                                    defmt::export::fmt(arg1);
                                    unsafe { defmt::export::release() }
                                }
                            }
                        };
                        if hole_size < required_size {
                            match (&(hole_size), &(required_size)) {
                                (arg0, arg1) => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path = "ucosii::heap::linked_list::hole"
                                                    .as_bytes();
                                                if if 6usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                        && module_path[2usize] == 111u8
                                                        && module_path[3usize] == 115u8
                                                        && module_path[4usize] == 105u8
                                                        && module_path[5usize] == 105u8
                                                        && if 6usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[6usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe { defmt::export::acquire() };
                                        defmt::export::header(
                                            &{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"hole_size is: {}, required_size is: {}\",\"disambiguator\":\"15019664947355469322\",\"crate_name\":\"ucosii\"}"]
                                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"hole_size is: {}, required_size is: {}\",\"disambiguator\":\"15019664947355469322\",\"crate_name\":\"ucosii\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            },
                                        );
                                        defmt::export::fmt(arg0);
                                        defmt::export::fmt(arg1);
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path = "ucosii::heap::linked_list::hole"
                                                    .as_bytes();
                                                if if 6usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                        && module_path[2usize] == 111u8
                                                        && module_path[3usize] == 115u8
                                                        && module_path[4usize] == 105u8
                                                        && module_path[5usize] == 105u8
                                                        && if 6usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[6usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe { defmt::export::acquire() };
                                        defmt::export::header(
                                            &{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"hole_size < required_size\",\"disambiguator\":\"3632644332757000007\",\"crate_name\":\"ucosii\"}"]
                                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"hole_size < required_size\",\"disambiguator\":\"3632644332757000007\",\"crate_name\":\"ucosii\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            },
                                        );
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            return Err(self);
                        }
                        let aligned_addr = if hole_addr_u8
                            == align_up(hole_addr_u8, required_align)
                        {
                            front_padding = None;
                            hole_addr_u8
                        } else {
                            let new_start = hole_addr_u8
                                .wrapping_add(HoleList::min_size());
                            let aligned_addr = align_up(new_start, required_align);
                            front_padding = Some(HoleInfo {
                                addr: hole_addr_u8,
                                size: (aligned_addr as usize) - (hole_addr_u8 as usize),
                            });
                            aligned_addr
                        };
                        let allocation_end = aligned_addr.wrapping_add(required_size);
                        let hole_end = hole_addr_u8.wrapping_add(hole_size);
                        if allocation_end > hole_end {
                            match () {
                                () => {
                                    if {
                                        const CHECK: bool = {
                                            const fn check() -> bool {
                                                let module_path = "ucosii::heap::linked_list::hole"
                                                    .as_bytes();
                                                if if 6usize > module_path.len() {
                                                    false
                                                } else {
                                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                        && module_path[2usize] == 111u8
                                                        && module_path[3usize] == 115u8
                                                        && module_path[4usize] == 105u8
                                                        && module_path[5usize] == 105u8
                                                        && if 6usize == module_path.len() {
                                                            true
                                                        } else {
                                                            module_path[6usize] == b':'
                                                        }
                                                } {
                                                    return true;
                                                }
                                                false
                                            }
                                            check()
                                        };
                                        CHECK
                                    } {
                                        unsafe { defmt::export::acquire() };
                                        defmt::export::header(
                                            &{
                                                defmt::export::make_istr({
                                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"allocation_end > hole_end\",\"disambiguator\":\"18141496736188175810\",\"crate_name\":\"ucosii\"}"]
                                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"allocation_end > hole_end\",\"disambiguator\":\"18141496736188175810\",\"crate_name\":\"ucosii\"}"]
                                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                })
                                            },
                                        );
                                        unsafe { defmt::export::release() }
                                    }
                                }
                            };
                            return Err(self);
                        }
                        alloc_ptr = aligned_addr;
                        alloc_size = required_size;
                        let back_padding_size = hole_end as usize
                            - allocation_end as usize;
                        back_padding = if back_padding_size == 0 {
                            None
                        } else {
                            let hole_layout = Layout::new::<Hole>();
                            let back_padding_start = align_up(
                                allocation_end,
                                hole_layout.align(),
                            );
                            let back_padding_end = back_padding_start
                                .wrapping_add(hole_layout.size());
                            if back_padding_end <= hole_end {
                                Some(HoleInfo {
                                    addr: back_padding_start,
                                    size: back_padding_size,
                                })
                            } else {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path = "ucosii::heap::linked_list::hole"
                                                        .as_bytes();
                                                    if if 6usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                            && module_path[2usize] == 111u8
                                                            && module_path[3usize] == 115u8
                                                            && module_path[4usize] == 105u8
                                                            && module_path[5usize] == 105u8
                                                            && if 6usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[6usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe { defmt::export::acquire() };
                                            defmt::export::header(
                                                &{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"back_padding_end > hole_end\",\"disambiguator\":\"7060038994476726531\",\"crate_name\":\"ucosii\"}"]
                                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"back_padding_end > hole_end\",\"disambiguator\":\"7060038994476726531\",\"crate_name\":\"ucosii\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                },
                                            );
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                return Err(self);
                            }
                        };
                    }
                    let Cursor { mut prev, mut hole, .. } = self;
                    unsafe {
                        prev.as_mut().next = None;
                    }
                    let maybe_next_addr: Option<NonNull<Hole>> = unsafe {
                        hole.as_mut().next.take()
                    };
                    match (front_padding, back_padding) {
                        (None, None) => {
                            unsafe {
                                prev.as_mut().next = maybe_next_addr;
                            }
                        }
                        (None, Some(singlepad)) | (Some(singlepad), None) => {
                            unsafe {
                                let singlepad_ptr = singlepad.addr.cast::<Hole>();
                                singlepad_ptr
                                    .write(Hole {
                                        size: singlepad.size,
                                        next: maybe_next_addr,
                                    });
                                prev.as_mut().next = Some(
                                    NonNull::new_unchecked(singlepad_ptr),
                                );
                            }
                        }
                        (Some(frontpad), Some(backpad)) => {
                            unsafe {
                                let backpad_ptr = backpad.addr.cast::<Hole>();
                                backpad_ptr
                                    .write(Hole {
                                        size: backpad.size,
                                        next: maybe_next_addr,
                                    });
                                let frontpad_ptr = frontpad.addr.cast::<Hole>();
                                frontpad_ptr
                                    .write(Hole {
                                        size: frontpad.size,
                                        next: Some(NonNull::new_unchecked(backpad_ptr)),
                                    });
                                prev.as_mut().next = Some(
                                    NonNull::new_unchecked(frontpad_ptr),
                                );
                            }
                        }
                    }
                    Ok((alloc_ptr, alloc_size))
                }
            }
            fn check_merge_top(mut node: NonNull<Hole>, top: *mut u8) {
                let node_u8 = node.as_ptr().cast::<u8>();
                let node_sz = unsafe { node.as_ref().size };
                let end = node_u8.wrapping_add(node_sz);
                let hole_layout = Layout::new::<Hole>();
                if end < top {
                    let next_hole_end = align_up(end, hole_layout.align())
                        .wrapping_add(hole_layout.size());
                    if next_hole_end > top {
                        let offset = (top as usize) - (end as usize);
                        unsafe {
                            node.as_mut().size += offset;
                        }
                    }
                }
            }
            fn check_merge_bottom(
                node: NonNull<Hole>,
                bottom: *mut u8,
            ) -> NonNull<Hole> {
                if true {
                    match (&(bottom as usize % align_of::<Hole>()), &0) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                }
                if bottom.wrapping_add(core::mem::size_of::<Hole>())
                    > node.as_ptr().cast::<u8>()
                {
                    let offset = (node.as_ptr() as usize) - (bottom as usize);
                    let size = unsafe { node.as_ref() }.size + offset;
                    unsafe { make_hole(bottom, size) }
                } else {
                    node
                }
            }
            impl HoleList {
                /// Creates an empty `HoleList`.
                pub const fn empty() -> HoleList {
                    HoleList {
                        first: Hole { size: 0, next: None },
                        bottom: null_mut(),
                        top: null_mut(),
                        pending_extend: 0,
                    }
                }
                pub(crate) fn cursor(&mut self) -> Option<Cursor> {
                    if let Some(hole) = self.first.next {
                        Some(Cursor {
                            hole,
                            prev: NonNull::new(&mut self.first)?,
                            top: self.top,
                        })
                    } else {
                        None
                    }
                }
                /// Creates a `HoleList` that contains the given hole.
                ///
                /// The `hole_addr` pointer is automatically aligned, so the `bottom`
                /// field might be larger than the given `hole_addr`.
                ///
                /// The given `hole_size` must be large enough to store the required
                /// metadata, otherwise this function will panic. Depending on the
                /// alignment of the `hole_addr` pointer, the minimum size is between
                /// `2 * size_of::<usize>` and `3 * size_of::<usize>`.
                ///
                /// The usable size for allocations will be truncated to the nearest
                /// alignment of `align_of::<usize>`. Any extra bytes left at the end
                /// will be reclaimed once sufficient additional space is given to
                /// [`extend`][crate::Heap::extend].
                ///
                /// # Safety
                ///
                /// This function is unsafe because it creates a hole at the given `hole_addr`.
                /// This can cause undefined behavior if this address is invalid or if memory from the
                /// `[hole_addr, hole_addr+size)` range is used somewhere else.
                pub unsafe fn new(hole_addr: *mut u8, hole_size: usize) -> HoleList {
                    match (&size_of::<Hole>(), &Self::min_size()) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                    if !(hole_size >= size_of::<Hole>()) {
                        ::core::panicking::panic(
                            "assertion failed: hole_size >= size_of::<Hole>()",
                        )
                    }
                    let aligned_hole_addr = align_up(hole_addr, align_of::<Hole>());
                    let requested_hole_size = hole_size
                        - ((aligned_hole_addr as usize) - (hole_addr as usize));
                    let aligned_hole_size = align_down_size(
                        requested_hole_size,
                        align_of::<Hole>(),
                    );
                    if !(aligned_hole_size >= size_of::<Hole>()) {
                        ::core::panicking::panic(
                            "assertion failed: aligned_hole_size >= size_of::<Hole>()",
                        )
                    }
                    let ptr = aligned_hole_addr as *mut Hole;
                    ptr.write(Hole {
                        size: aligned_hole_size,
                        next: None,
                    });
                    match (
                        &hole_addr.wrapping_add(hole_size),
                        &aligned_hole_addr.wrapping_add(requested_hole_size),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    };
                    HoleList {
                        first: Hole {
                            size: 0,
                            next: Some(NonNull::new_unchecked(ptr)),
                        },
                        bottom: aligned_hole_addr,
                        top: aligned_hole_addr.wrapping_add(aligned_hole_size),
                        pending_extend: (requested_hole_size - aligned_hole_size) as u8,
                    }
                }
                /// Aligns the given layout for use with `HoleList`.
                ///
                /// Returns a layout with size increased to fit at least `HoleList::min_size` and proper
                /// alignment of a `Hole`.
                ///
                /// The [`allocate_first_fit`][HoleList::allocate_first_fit] and
                /// [`deallocate`][HoleList::deallocate] methods perform the required alignment
                /// themselves, so calling this function manually is not necessary.
                pub fn align_layout(layout: Layout) -> Result<Layout, LayoutError> {
                    let mut size = layout.size();
                    if size < Self::min_size() {
                        size = Self::min_size();
                    }
                    let size = align_up_size(size, mem::align_of::<Hole>());
                    Layout::from_size_align(size, layout.align())
                }
                /// Searches the list for a big enough hole.
                ///
                /// A hole is big enough if it can hold an allocation of `layout.size()` bytes with
                /// the given `layout.align()`. If such a hole is found in the list, a block of the
                /// required size is allocated from it. Then the start address of that
                /// block and the aligned layout are returned. The automatic layout alignment is required
                /// because the `HoleList` has some additional layout requirements for each memory block.
                ///
                /// This function uses the first fit strategy, so it uses the first hole that is big
                /// enough. Thus the runtime is in O(n) but it should be reasonably fast for small allocations.
                #[allow(clippy::result_unit_err)]
                pub fn allocate_first_fit(
                    &mut self,
                    layout: Layout,
                ) -> Result<(NonNull<u8>, Layout), ()> {
                    let aligned_layout = Self::align_layout(layout).map_err(|_| ())?;
                    let mut cursor = self.cursor().ok_or(())?;
                    loop {
                        match cursor.split_current(aligned_layout) {
                            Ok((ptr, _len)) => {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path = "ucosii::heap::linked_list::hole"
                                                        .as_bytes();
                                                    if if 6usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                            && module_path[2usize] == 111u8
                                                            && module_path[3usize] == 115u8
                                                            && module_path[4usize] == 105u8
                                                            && module_path[5usize] == 105u8
                                                            && if 6usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[6usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe { defmt::export::acquire() };
                                            defmt::export::header(
                                                &{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in allocate_first_fit ok\",\"disambiguator\":\"2849554555196979225\",\"crate_name\":\"ucosii\"}"]
                                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in allocate_first_fit ok\",\"disambiguator\":\"2849554555196979225\",\"crate_name\":\"ucosii\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                },
                                            );
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                return Ok((NonNull::new(ptr).ok_or(())?, aligned_layout));
                            }
                            Err(curs) => {
                                match () {
                                    () => {
                                        if {
                                            const CHECK: bool = {
                                                const fn check() -> bool {
                                                    let module_path = "ucosii::heap::linked_list::hole"
                                                        .as_bytes();
                                                    if if 6usize > module_path.len() {
                                                        false
                                                    } else {
                                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                                            && module_path[2usize] == 111u8
                                                            && module_path[3usize] == 115u8
                                                            && module_path[4usize] == 105u8
                                                            && module_path[5usize] == 105u8
                                                            && if 6usize == module_path.len() {
                                                                true
                                                            } else {
                                                                module_path[6usize] == b':'
                                                            }
                                                    } {
                                                        return true;
                                                    }
                                                    false
                                                }
                                                check()
                                            };
                                            CHECK
                                        } {
                                            unsafe { defmt::export::acquire() };
                                            defmt::export::header(
                                                &{
                                                    defmt::export::make_istr({
                                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in allocate_first_fit error\",\"disambiguator\":\"15554796028119703771\",\"crate_name\":\"ucosii\"}"]
                                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in allocate_first_fit error\",\"disambiguator\":\"15554796028119703771\",\"crate_name\":\"ucosii\"}"]
                                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                                    })
                                                },
                                            );
                                            unsafe { defmt::export::release() }
                                        }
                                    }
                                };
                                cursor = curs.next().ok_or(())?;
                            }
                        }
                    }
                }
                /// Frees the allocation given by `ptr` and `layout`.
                ///
                /// This function walks the list and inserts the given block at the correct place. If the freed
                /// block is adjacent to another free block, the blocks are merged again.
                /// This operation is in `O(n)` since the list needs to be sorted by address.
                ///
                /// [`allocate_first_fit`]: HoleList::allocate_first_fit
                ///
                /// # Safety
                ///
                /// `ptr` must be a pointer returned by a call to the [`allocate_first_fit`] function with
                /// identical layout. Undefined behavior may occur for invalid arguments.
                /// The function performs exactly the same layout adjustments as [`allocate_first_fit`] and
                /// returns the aligned layout.
                pub unsafe fn deallocate(
                    &mut self,
                    ptr: NonNull<u8>,
                    layout: Layout,
                ) -> Layout {
                    let aligned_layout = Self::align_layout(layout).unwrap();
                    deallocate(self, ptr.as_ptr(), aligned_layout.size());
                    aligned_layout
                }
                /// Returns the minimal allocation size. Smaller allocations or deallocations are not allowed.
                pub fn min_size() -> usize {
                    size_of::<usize>() * 2
                }
                pub(crate) unsafe fn extend(&mut self, by: usize) {
                    if !!self.top.is_null() {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("tried to extend an empty heap"),
                            );
                        }
                    }
                    let top = self.top;
                    let dead_space = top.align_offset(align_of::<Hole>());
                    if true {
                        match (&0, &dead_space) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::Some(
                                            format_args!(
                                                "dead space detected during extend: {0} bytes. This means top was unaligned",
                                                dead_space,
                                            ),
                                        ),
                                    );
                                }
                            }
                        };
                    }
                    if true {
                        if !((self.pending_extend as usize) < Self::min_size()) {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("pending extend was larger than expected"),
                                );
                            }
                        }
                    }
                    let extend_by = self.pending_extend as usize + by;
                    let minimum_extend = Self::min_size();
                    if extend_by < minimum_extend {
                        self.pending_extend = extend_by as u8;
                        return;
                    }
                    let new_hole_size = align_down_size(extend_by, align_of::<Hole>());
                    let layout = Layout::from_size_align(new_hole_size, 1).unwrap();
                    self.deallocate(NonNull::new_unchecked(top as *mut u8), layout);
                    self.top = top.add(new_hole_size);
                    self.pending_extend = (extend_by - new_hole_size) as u8;
                }
            }
            unsafe fn make_hole(addr: *mut u8, size: usize) -> NonNull<Hole> {
                let hole_addr = addr.cast::<Hole>();
                if true {
                    match (&(addr as usize % align_of::<Hole>()), &0) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(
                                        format_args!("Hole address not aligned!"),
                                    ),
                                );
                            }
                        }
                    };
                }
                hole_addr.write(Hole { size, next: None });
                NonNull::new_unchecked(hole_addr)
            }
            impl Cursor {
                fn try_insert_back(
                    self,
                    node: NonNull<Hole>,
                    bottom: *mut u8,
                ) -> Result<Self, Self> {
                    if node < self.hole {
                        let node_u8 = node.as_ptr().cast::<u8>();
                        let node_size = unsafe { node.as_ref().size };
                        let hole_u8 = self.hole.as_ptr().cast::<u8>();
                        if !(node_u8.wrapping_add(node_size) <= hole_u8) {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("Freed node aliases existing hole! Bad free?"),
                                );
                            }
                        }
                        if true {
                            match (&self.previous().size, &0) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        ::core::panicking::assert_failed(
                                            kind,
                                            &*left_val,
                                            &*right_val,
                                            ::core::option::Option::None,
                                        );
                                    }
                                }
                            };
                        }
                        let Cursor { mut prev, hole, top } = self;
                        unsafe {
                            let mut node = check_merge_bottom(node, bottom);
                            prev.as_mut().next = Some(node);
                            node.as_mut().next = Some(hole);
                        }
                        Ok(Cursor { prev, hole: node, top })
                    } else {
                        Err(self)
                    }
                }
                fn try_insert_after(
                    &mut self,
                    mut node: NonNull<Hole>,
                ) -> Result<(), ()> {
                    let node_u8 = node.as_ptr().cast::<u8>();
                    let node_size = unsafe { node.as_ref().size };
                    if let Some(next) = self.current().next.as_ref() {
                        if node < *next {
                            let node_u8 = node_u8 as *const u8;
                            if !(node_u8.wrapping_add(node_size)
                                <= next.as_ptr().cast::<u8>())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!("Freed node aliases existing hole! Bad free?"),
                                    );
                                }
                            }
                        } else {
                            return Err(());
                        }
                    }
                    if true {
                        if !(self.hole < node) {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!("Hole list out of order?"),
                                );
                            }
                        }
                    }
                    let hole_u8 = self.hole.as_ptr().cast::<u8>();
                    let hole_size = self.current().size;
                    if !(hole_u8.wrapping_add(hole_size) <= node_u8) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Freed node ({0:?}) aliases existing hole ({1:?}[{2}])! Bad free?",
                                    node_u8,
                                    hole_u8,
                                    hole_size,
                                ),
                            );
                        }
                    }
                    unsafe {
                        let maybe_next = self.hole.as_mut().next.replace(node);
                        node.as_mut().next = maybe_next;
                    }
                    Ok(())
                }
                fn try_merge_next_n(self, max: usize) {
                    let Cursor { prev: _, mut hole, top, .. } = self;
                    for _ in 0..max {
                        let mut next = if let Some(next) = unsafe { hole.as_mut() }
                            .next
                            .as_ref()
                        {
                            *next
                        } else {
                            check_merge_top(hole, top);
                            return;
                        };
                        let hole_u8 = hole.as_ptr().cast::<u8>();
                        let hole_sz = unsafe { hole.as_ref().size };
                        let next_u8 = next.as_ptr().cast::<u8>();
                        let end = hole_u8.wrapping_add(hole_sz);
                        let touching = end == next_u8;
                        if touching {
                            let next_sz;
                            let next_next;
                            unsafe {
                                let next_mut = next.as_mut();
                                next_sz = next_mut.size;
                                next_next = next_mut.next.take();
                            }
                            unsafe {
                                let hole_mut = hole.as_mut();
                                hole_mut.next = next_next;
                                hole_mut.size += next_sz;
                            }
                        } else {
                            hole = next;
                        }
                    }
                }
            }
            /// Frees the allocation given by `(addr, size)`. It starts at the given hole and walks the list to
            /// find the correct place (the list is sorted by address).
            fn deallocate(list: &mut HoleList, addr: *mut u8, size: usize) {
                let hole = unsafe { make_hole(addr, size) };
                let cursor = if let Some(cursor) = list.cursor() {
                    cursor
                } else {
                    let hole = check_merge_bottom(hole, list.bottom);
                    check_merge_top(hole, list.top);
                    list.first.next = Some(hole);
                    return;
                };
                let (cursor, n) = match cursor.try_insert_back(hole, list.bottom) {
                    Ok(cursor) => (cursor, 1),
                    Err(mut cursor) => {
                        while let Err(()) = cursor.try_insert_after(hole) {
                            cursor = cursor
                                .next()
                                .expect(
                                    "Reached end of holes without finding deallocation hole!",
                                );
                        }
                        (cursor, 2)
                    }
                };
                cursor.try_merge_next_n(n);
            }
        }
        /// A fixed size heap backed by a linked list of free memory blocks.
        pub struct Heap {
            used: usize,
            holes: HoleList,
        }
        unsafe impl Send for Heap {}
        impl Heap {
            /// Creates an empty heap. All allocate calls will return `None`.
            pub const fn empty() -> Heap {
                Heap {
                    used: 0,
                    holes: HoleList::empty(),
                }
            }
            /// Initializes an empty heap
            ///
            /// The `heap_bottom` pointer is automatically aligned, so the [`bottom()`][Self::bottom]
            /// method might return a pointer that is larger than `heap_bottom` after construction.
            ///
            /// The given `heap_size` must be large enough to store the required
            /// metadata, otherwise this function will panic. Depending on the
            /// alignment of the `hole_addr` pointer, the minimum size is between
            /// `2 * size_of::<usize>` and `3 * size_of::<usize>`.
            ///
            /// The usable size for allocations will be truncated to the nearest
            /// alignment of `align_of::<usize>`. Any extra bytes left at the end
            /// will be reclaimed once sufficient additional space is given to
            /// [`extend`][Heap::extend].
            ///
            /// # Safety
            ///
            /// This function must be called at most once and must only be used on an
            /// empty heap.
            ///
            /// The bottom address must be valid and the memory in the
            /// `[heap_bottom, heap_bottom + heap_size)` range must not be used for anything else.
            /// This function is unsafe because it can cause undefined behavior if the given address
            /// is invalid.
            ///
            /// The provided memory range must be valid for the `'static` lifetime.
            pub unsafe fn init(&mut self, heap_bottom: *mut u8, heap_size: usize) {
                self.used = 0;
                self.holes = HoleList::new(heap_bottom, heap_size);
            }
            /// Initialize an empty heap with provided memory.
            ///
            /// The caller is responsible for procuring a region of raw memory that may be utilized by the
            /// allocator. This might be done via any method such as (unsafely) taking a region from the
            /// program's memory, from a mutable static, or by allocating and leaking such memory from
            /// another allocator.
            ///
            /// The latter approach may be especially useful if the underlying allocator does not perform
            /// deallocation (e.g. a simple bump allocator). Then the overlaid linked-list-allocator can
            /// provide memory reclamation.
            ///
            /// The usable size for allocations will be truncated to the nearest
            /// alignment of `align_of::<usize>`. Any extra bytes left at the end
            /// will be reclaimed once sufficient additional space is given to
            /// [`extend`][Heap::extend].
            ///
            /// # Panics
            ///
            /// This method panics if the heap is already initialized.
            ///
            /// It also panics when the length of the given `mem` slice is not large enough to
            /// store the required metadata. Depending on the alignment of the slice, the minimum
            /// size is between `2 * size_of::<usize>` and `3 * size_of::<usize>`.
            pub fn init_from_slice(&mut self, mem: &'static mut [MaybeUninit<u8>]) {
                if !self.bottom().is_null() {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("The heap has already been initialized."),
                        );
                    }
                }
                let size = mem.len();
                let address = mem.as_mut_ptr().cast();
                unsafe { self.init(address, size) }
            }
            /// Creates a new heap with the given `bottom` and `size`.
            ///
            /// The `heap_bottom` pointer is automatically aligned, so the [`bottom()`][Self::bottom]
            /// method might return a pointer that is larger than `heap_bottom` after construction.
            ///
            /// The given `heap_size` must be large enough to store the required
            /// metadata, otherwise this function will panic. Depending on the
            /// alignment of the `hole_addr` pointer, the minimum size is between
            /// `2 * size_of::<usize>` and `3 * size_of::<usize>`.
            ///
            /// The usable size for allocations will be truncated to the nearest
            /// alignment of `align_of::<usize>`. Any extra bytes left at the end
            /// will be reclaimed once sufficient additional space is given to
            /// [`extend`][Heap::extend].
            ///
            /// # Safety
            ///
            /// The bottom address must be valid and the memory in the
            /// `[heap_bottom, heap_bottom + heap_size)` range must not be used for anything else.
            /// This function is unsafe because it can cause undefined behavior if the given address
            /// is invalid.
            ///
            /// The provided memory range must be valid for the `'static` lifetime.
            pub unsafe fn new(heap_bottom: *mut u8, heap_size: usize) -> Heap {
                Heap {
                    used: 0,
                    holes: HoleList::new(heap_bottom, heap_size),
                }
            }
            /// Creates a new heap from a slice of raw memory.
            ///
            /// This is a convenience function that has the same effect as calling
            /// [`init_from_slice`] on an empty heap. All the requirements of `init_from_slice`
            /// apply to this function as well.
            pub fn from_slice(mem: &'static mut [MaybeUninit<u8>]) -> Heap {
                let size = mem.len();
                let address = mem.as_mut_ptr().cast();
                unsafe { Self::new(address, size) }
            }
            /// Allocates a chunk of the given size with the given alignment. Returns a pointer to the
            /// beginning of that chunk if it was successful. Else it returns `None`.
            /// This function scans the list of free memory blocks and uses the first block that is big
            /// enough. The runtime is in O(n) where n is the number of free blocks, but it should be
            /// reasonably fast for small allocations.
            #[allow(clippy::result_unit_err)]
            pub fn allocate_first_fit(
                &mut self,
                layout: Layout,
            ) -> Result<NonNull<u8>, ()> {
                match self.holes.allocate_first_fit(layout) {
                    Ok((ptr, aligned_layout)) => {
                        self.used += aligned_layout.size();
                        Ok(ptr)
                    }
                    Err(err) => Err(err),
                }
            }
            /// Frees the given allocation. `ptr` must be a pointer returned
            /// by a call to the `allocate_first_fit` function with identical size and alignment.
            ///
            /// This function walks the list of free memory blocks and inserts the freed block at the
            /// correct place. If the freed block is adjacent to another free block, the blocks are merged
            /// again. This operation is in `O(n)` since the list needs to be sorted by address.
            ///
            /// # Safety
            ///
            /// `ptr` must be a pointer returned by a call to the [`allocate_first_fit`] function with
            /// identical layout. Undefined behavior may occur for invalid arguments.
            pub unsafe fn deallocate(&mut self, ptr: NonNull<u8>, layout: Layout) {
                self.used -= self.holes.deallocate(ptr, layout).size();
            }
            /// Returns the bottom address of the heap.
            ///
            /// The bottom pointer is automatically aligned, so the returned pointer
            /// might be larger than the bottom pointer used for initialization.
            pub fn bottom(&self) -> *mut u8 {
                self.holes.bottom
            }
            /// Returns the size of the heap.
            ///
            /// This is the size the heap is using for allocations, not necessarily the
            /// total amount of bytes given to the heap. To determine the exact memory
            /// boundaries, use [`bottom`][Self::bottom] and [`top`][Self::top].
            pub fn size(&self) -> usize {
                unsafe { self.holes.top.offset_from(self.holes.bottom) as usize }
            }
            /// Return the top address of the heap.
            ///
            /// Note: The heap may choose to not use bytes at the end for allocations
            /// until there is enough room for metadata, but it still retains ownership
            /// over memory from [`bottom`][Self::bottom] to the address returned.
            pub fn top(&self) -> *mut u8 {
                unsafe { self.holes.top.add(self.holes.pending_extend as usize) }
            }
            /// Returns the size of the used part of the heap
            pub fn used(&self) -> usize {
                self.used
            }
            /// Returns the size of the free part of the heap
            pub fn free(&self) -> usize {
                self.size() - self.used
            }
            /// Extends the size of the heap by creating a new hole at the end.
            ///
            /// Small extensions are not guaranteed to grow the usable size of
            /// the heap. In order to grow the Heap most effectively, extend by
            /// at least `2 * size_of::<usize>`, keeping the amount a multiple of
            /// `size_of::<usize>`.
            ///
            /// Calling this method on an uninitialized Heap will panic.
            ///
            /// # Safety
            ///
            /// The amount of data given in `by` MUST exist directly after the original
            /// range of data provided when constructing the [Heap]. The additional data
            /// must have the same lifetime of the original range of data.
            ///
            /// Even if this operation doesn't increase the [usable size][`Self::size`]
            /// by exactly `by` bytes, those bytes are still owned by the Heap for
            /// later use.
            pub unsafe fn extend(&mut self, by: usize) {
                self.holes.extend(by);
            }
        }
        #[cfg(feature = "use_spin")]
        pub struct LockedHeap(Spinlock<Heap>);
        #[cfg(feature = "use_spin")]
        impl LockedHeap {
            pub const fn empty() -> LockedHeap {
                LockedHeap(Spinlock::new(Heap::empty()))
            }
            /// Creates a new heap with the given `bottom` and `size`.
            ///
            /// The `heap_bottom` pointer is automatically aligned, so the [`bottom()`][Heap::bottom]
            /// method might return a pointer that is larger than `heap_bottom` after construction.
            ///
            /// The given `heap_size` must be large enough to store the required
            /// metadata, otherwise this function will panic. Depending on the
            /// alignment of the `hole_addr` pointer, the minimum size is between
            /// `2 * size_of::<usize>` and `3 * size_of::<usize>`.
            ///
            /// # Safety
            ///
            /// The bottom address must be valid and the memory in the
            /// `[heap_bottom, heap_bottom + heap_size)` range must not be used for anything else.
            /// This function is unsafe because it can cause undefined behavior if the given address
            /// is invalid.
            ///
            /// The provided memory range must be valid for the `'static` lifetime.
            pub unsafe fn new(heap_bottom: *mut u8, heap_size: usize) -> LockedHeap {
                LockedHeap(
                    Spinlock::new(Heap {
                        used: 0,
                        holes: HoleList::new(heap_bottom, heap_size),
                    }),
                )
            }
        }
        #[cfg(feature = "use_spin")]
        impl Deref for LockedHeap {
            type Target = Spinlock<Heap>;
            fn deref(&self) -> &Spinlock<Heap> {
                &self.0
            }
        }
        #[cfg(feature = "use_spin")]
        unsafe impl GlobalAlloc for LockedHeap {
            unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
                self.0
                    .lock()
                    .allocate_first_fit(layout)
                    .ok()
                    .map_or(core::ptr::null_mut(), |allocation| allocation.as_ptr())
            }
            unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
                self.0.lock().deallocate(NonNull::new_unchecked(ptr), layout)
            }
        }
        /// Align downwards. Returns the greatest x with alignment `align`
        /// so that x <= addr. The alignment must be a power of 2.
        pub fn align_down_size(size: usize, align: usize) -> usize {
            if align.is_power_of_two() {
                size & !(align - 1)
            } else if align == 0 {
                size
            } else {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("`align` must be a power of 2"),
                    );
                };
            }
        }
        pub fn align_up_size(size: usize, align: usize) -> usize {
            align_down_size(size + align - 1, align)
        }
        /// Align upwards. Returns the smallest x with alignment `align`
        /// so that x >= addr. The alignment must be a power of 2.
        pub fn align_up(addr: *mut u8, align: usize) -> *mut u8 {
            let offset = addr.align_offset(align);
            addr.wrapping_add(offset)
        }
    }
    pub mod stack_allocator {
        use alloc::alloc::{GlobalAlloc, Layout};
        use core::ptr::NonNull;
        use defmt::info;
        use super::fixed_size_block::FixedSizeBlockAllocator;
        use super::Locked;
        pub const STACK_START: *mut u8 = 0x20000000 as *mut u8;
        pub const STACK_SIZE: usize = 40 * 1024;
        pub const PROGRAM_STACK_SIZE: usize = 4096;
        pub const INTERRUPT_STACK_SIZE: usize = 2048;
        pub const TASK_STACK_SIZE: usize = PROGRAM_STACK_SIZE;
        use crate::port::OS_STK;
        use crate::sync::UPSafeCell;
        static STACK_ALLOCATOR: Locked<FixedSizeBlockAllocator> = Locked::new(
            FixedSizeBlockAllocator::new(),
        );
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        pub struct PROGRAM_STACK {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        pub static PROGRAM_STACK: PROGRAM_STACK = PROGRAM_STACK {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for PROGRAM_STACK {
            type Target = UPSafeCell<OS_STK_REF>;
            fn deref(&self) -> &UPSafeCell<OS_STK_REF> {
                #[inline(always)]
                fn __static_ref_initialize() -> UPSafeCell<OS_STK_REF> {
                    unsafe { UPSafeCell::new(OS_STK_REF::default()) }
                }
                #[inline(always)]
                fn __stability() -> &'static UPSafeCell<OS_STK_REF> {
                    static LAZY: ::lazy_static::lazy::Lazy<UPSafeCell<OS_STK_REF>> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for PROGRAM_STACK {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        pub struct INTERRUPT_STACK {
            __private_field: (),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        pub static INTERRUPT_STACK: INTERRUPT_STACK = INTERRUPT_STACK {
            __private_field: (),
        };
        impl ::lazy_static::__Deref for INTERRUPT_STACK {
            type Target = UPSafeCell<OS_STK_REF>;
            fn deref(&self) -> &UPSafeCell<OS_STK_REF> {
                #[inline(always)]
                fn __static_ref_initialize() -> UPSafeCell<OS_STK_REF> {
                    unsafe { UPSafeCell::new(OS_STK_REF::default()) }
                }
                #[inline(always)]
                fn __stability() -> &'static UPSafeCell<OS_STK_REF> {
                    static LAZY: ::lazy_static::lazy::Lazy<UPSafeCell<OS_STK_REF>> = ::lazy_static::lazy::Lazy::INIT;
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
        impl ::lazy_static::LazyStatic for INTERRUPT_STACK {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        pub fn init_stack_allocator() {
            unsafe {
                match (&(STACK_SIZE)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::heap::stack_allocator"
                                        .as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in the init, the STACK_SIZE is :{}\",\"disambiguator\":\"17876897900478854386\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"in the init, the STACK_SIZE is :{}\",\"disambiguator\":\"17876897900478854386\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                STACK_ALLOCATOR.lock().init(STACK_START, STACK_SIZE);
            }
            let layout = Layout::from_size_align(PROGRAM_STACK_SIZE, 4).unwrap();
            let stk = alloc_stack(layout);
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::heap::stack_allocator"
                                    .as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alloc the psp\",\"disambiguator\":\"1617303851432631177\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alloc the psp\",\"disambiguator\":\"1617303851432631177\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let stk_ptr = stk.STK_REF.as_ptr() as *mut u8;
            PROGRAM_STACK.set(stk);
            extern "Rust" {
                fn set_program_sp(sp: *mut u8);
            }
            unsafe {
                set_program_sp(stk_ptr);
            }
            let layout = Layout::from_size_align(INTERRUPT_STACK_SIZE, 4).unwrap();
            let stk = alloc_stack(layout);
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::heap::stack_allocator"
                                    .as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alloc the msp\",\"disambiguator\":\"14081091083264982245\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alloc the msp\",\"disambiguator\":\"14081091083264982245\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            INTERRUPT_STACK.set(stk);
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::heap::stack_allocator"
                                    .as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the end of the init_stack_allocator\",\"disambiguator\":\"10493720535131400997\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"the end of the init_stack_allocator\",\"disambiguator\":\"10493720535131400997\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
        }
        /// alloc a new stack
        pub fn alloc_stack(layout: Layout) -> OS_STK_REF {
            match () {
                () => {
                    if {
                        const CHECK: bool = {
                            const fn check() -> bool {
                                let module_path = "ucosii::heap::stack_allocator"
                                    .as_bytes();
                                if if 6usize > module_path.len() {
                                    false
                                } else {
                                    module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                        && module_path[2usize] == 111u8
                                        && module_path[3usize] == 115u8
                                        && module_path[4usize] == 105u8
                                        && module_path[5usize] == 105u8
                                        && if 6usize == module_path.len() {
                                            true
                                        } else {
                                            module_path[6usize] == b':'
                                        }
                                } {
                                    return true;
                                }
                                false
                            }
                            check()
                        };
                        CHECK
                    } {
                        unsafe { defmt::export::acquire() };
                        defmt::export::header(
                            &{
                                defmt::export::make_istr({
                                    #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alloc_stack\",\"disambiguator\":\"78808725411623544\",\"crate_name\":\"ucosii\"}"]
                                    #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"alloc_stack\",\"disambiguator\":\"78808725411623544\",\"crate_name\":\"ucosii\"}"]
                                    static DEFMT_LOG_STATEMENT: u8 = 0;
                                    &DEFMT_LOG_STATEMENT as *const u8 as u16
                                })
                            },
                        );
                        unsafe { defmt::export::release() }
                    }
                }
            };
            let heap_ptr: *mut u8;
            unsafe {
                heap_ptr = STACK_ALLOCATOR.alloc(layout);
            }
            stk_from_ptr(heap_ptr, layout)
        }
        /// dealloc a stack
        pub fn dealloc_stack(stk: &mut OS_STK_REF) {
            if stk.STK_REF == NonNull::dangling() || stk.HEAP_REF == NonNull::dangling()
            {
                return;
            }
            let stk_ptr = stk.HEAP_REF.as_ptr();
            stk.STK_REF = NonNull::dangling();
            stk.HEAP_REF = NonNull::dangling();
            unsafe {
                STACK_ALLOCATOR.dealloc(stk_ptr, stk.layout);
            }
        }
        /// the ref of the stk
        pub struct OS_STK_REF {
            /// the ref of the stk(top or bottom),because the read of this
            /// field is in the asm code, so we use NonNull to ensure the safety
            /// and use #[allow(dead_code)]
            #[allow(dead_code)]
            pub STK_REF: NonNull<OS_STK>,
            /// the ref of this dynamic stk's src heap
            pub HEAP_REF: NonNull<u8>,
            /// the layout(size) of the stk
            pub layout: Layout,
        }
        unsafe impl Send for OS_STK_REF {}
        impl Clone for OS_STK_REF {
            fn clone(&self) -> Self {
                OS_STK_REF {
                    STK_REF: self.STK_REF,
                    HEAP_REF: self.HEAP_REF,
                    layout: self.layout,
                }
            }
        }
        /// when the OS_STK_REF is default, we will not alloc a stack
        impl Default for OS_STK_REF {
            fn default() -> Self {
                OS_STK_REF {
                    STK_REF: NonNull::dangling(),
                    HEAP_REF: NonNull::dangling(),
                    layout: Layout::from_size_align(0, 1).unwrap(),
                }
            }
        }
        /// we impl drop for OS_STK_REF to dealloc the stack(try to be RAII)
        impl Drop for OS_STK_REF {
            fn drop(&mut self) {
                if self.STK_REF == NonNull::dangling()
                    || self.HEAP_REF == NonNull::dangling()
                {
                    return;
                }
                match (&(self.HEAP_REF.as_ptr() as usize)) {
                    (arg0) => {
                        if {
                            const CHECK: bool = {
                                const fn check() -> bool {
                                    let module_path = "ucosii::heap::stack_allocator"
                                        .as_bytes();
                                    if if 6usize > module_path.len() {
                                        false
                                    } else {
                                        module_path[0usize] == 117u8 && module_path[1usize] == 99u8
                                            && module_path[2usize] == 111u8
                                            && module_path[3usize] == 115u8
                                            && module_path[4usize] == 105u8
                                            && module_path[5usize] == 105u8
                                            && if 6usize == module_path.len() {
                                                true
                                            } else {
                                                module_path[6usize] == b':'
                                            }
                                    } {
                                        return true;
                                    }
                                    false
                                }
                                check()
                            };
                            CHECK
                        } {
                            unsafe { defmt::export::acquire() };
                            defmt::export::header(
                                &{
                                    defmt::export::make_istr({
                                        #[link_section = ".defmt.{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"drop stk has been called,the ptr is :{}\",\"disambiguator\":\"2345922817115421476\",\"crate_name\":\"ucosii\"}"]
                                        #[export_name = "{\"package\":\"ucosii\",\"tag\":\"defmt_info\",\"data\":\"drop stk has been called,the ptr is :{}\",\"disambiguator\":\"2345922817115421476\",\"crate_name\":\"ucosii\"}"]
                                        static DEFMT_LOG_STATEMENT: u8 = 0;
                                        &DEFMT_LOG_STATEMENT as *const u8 as u16
                                    })
                                },
                            );
                            defmt::export::fmt(arg0);
                            unsafe { defmt::export::release() }
                        }
                    }
                };
                let stk_ptr = self.HEAP_REF.as_ptr();
                self.STK_REF = NonNull::dangling();
                self.HEAP_REF = NonNull::dangling();
                unsafe {
                    STACK_ALLOCATOR.dealloc(stk_ptr, self.layout);
                }
            }
        }
        impl OS_STK_REF {
            pub fn as_ptr(&self) -> *mut u8 {
                self.HEAP_REF.as_ptr()
            }
        }
        pub fn stk_from_ptr(heap_ptr: *mut u8, layout: Layout) -> OS_STK_REF {
            OS_STK_REF {
                STK_REF: NonNull::new(unsafe {
                        heap_ptr.offset(layout.size() as isize) as *mut OS_STK
                    })
                    .unwrap(),
                HEAP_REF: NonNull::new(heap_ptr).unwrap(),
                layout,
            }
        }
    }
    use fixed_size_block::FixedSizeBlockAllocator;
    pub const HEAP_START: *mut u8 = 0x08000200 as *mut u8;
    pub const HEAP_SIZE: usize = 100 * 1024;
    static ALLOCATOR: Locked<FixedSizeBlockAllocator> = Locked::new(
        FixedSizeBlockAllocator::new(),
    );
    const _: () = {
        #[rustc_std_internal_symbol]
        unsafe fn __rust_alloc(size: usize, align: usize) -> *mut u8 {
            ::core::alloc::GlobalAlloc::alloc(
                &ALLOCATOR,
                ::core::alloc::Layout::from_size_align_unchecked(size, align),
            )
        }
        #[rustc_std_internal_symbol]
        unsafe fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize) -> () {
            ::core::alloc::GlobalAlloc::dealloc(
                &ALLOCATOR,
                ptr,
                ::core::alloc::Layout::from_size_align_unchecked(size, align),
            )
        }
        #[rustc_std_internal_symbol]
        unsafe fn __rust_realloc(
            ptr: *mut u8,
            size: usize,
            align: usize,
            new_size: usize,
        ) -> *mut u8 {
            ::core::alloc::GlobalAlloc::realloc(
                &ALLOCATOR,
                ptr,
                ::core::alloc::Layout::from_size_align_unchecked(size, align),
                new_size,
            )
        }
        #[rustc_std_internal_symbol]
        unsafe fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8 {
            ::core::alloc::GlobalAlloc::alloc_zeroed(
                &ALLOCATOR,
                ::core::alloc::Layout::from_size_align_unchecked(size, align),
            )
        }
    };
    #[allow(unused)]
    pub fn init_heap() {
        unsafe {
            ALLOCATOR.lock().init(HEAP_START, HEAP_SIZE);
        }
    }
    /// A wrapper around spin::Mutex to permit trait implementations.
    pub struct Locked<A> {
        inner: spin::Mutex<A>,
    }
    impl<A> Locked<A> {
        pub const fn new(inner: A) -> Self {
            Locked {
                inner: spin::Mutex::new(inner),
            }
        }
        pub fn lock(&self) -> spin::MutexGuard<A> {
            self.inner.lock()
        }
    }
}
mod sync {
    //! Synchronization and interior mutability primitives
    mod up {
        //! Uniprocessor interior mutability primitives
        use core::cell::{Ref, RefCell, RefMut};
        /// Wrap a static data structure inside it so that we are
        /// able to access it without any `unsafe`.
        ///
        /// We should only use it in uniprocessor.
        ///
        /// In order to get mutable reference of inner data, call
        /// `exclusive_access`.
        pub struct UPSafeCell<T> {
            /// inner data
            inner: RefCell<T>,
        }
        unsafe impl<T> Sync for UPSafeCell<T> {}
        impl<T> UPSafeCell<T> {
            /// User is responsible to guarantee that inner struct is only used in
            /// uniprocessor.
            pub unsafe fn new(value: T) -> Self {
                Self { inner: RefCell::new(value) }
            }
            /// Panic if the data has been borrowed.
            pub fn exclusive_access(&self) -> RefMut<'_, T> {
                self.inner.borrow_mut()
            }
            /// set the inner data
            pub fn set(&self, value: T) {
                *self.inner.borrow_mut() = value;
            }
            /// get the unmutable reference of inner data
            pub fn get(&self) -> Ref<'_, T> {
                self.inner.borrow()
            }
            /// set and return the old value
            pub fn swap(&self, value: T) -> T {
                let mut inner = self.inner.borrow_mut();
                core::mem::replace(&mut *inner, value)
            }
        }
    }
    pub use up::UPSafeCell;
}
/// the apps
pub mod app {
    /// the mod which set the LED
    pub mod led {
        use stm32_metapac::{self, gpio::vals, GPIOA, RCC};
        /// init the LED
        #[allow(dead_code)]
        pub fn LED_Init() {
            RCC.ahb1enr()
                .modify(|v| {
                    v.set_gpioaen(true);
                });
            GPIOA
                .moder()
                .modify(|v| {
                    v.set_moder(5, vals::Moder::OUTPUT);
                });
            GPIOA
                .otyper()
                .modify(|v| {
                    v.set_ot(5, vals::Ot::PUSHPULL);
                });
            GPIOA
                .ospeedr()
                .modify(|v| {
                    v.set_ospeedr(5, vals::Ospeedr::HIGHSPEED);
                });
            GPIOA
                .pupdr()
                .modify(|v| {
                    v.set_pupdr(5, vals::Pupdr::FLOATING);
                });
            GPIOA
                .odr()
                .modify(|v| {
                    v.set_odr(5, vals::Odr::HIGH);
                });
        }
        /// turn on the LED
        #[allow(dead_code)]
        #[inline]
        pub fn LED_ON() {
            GPIOA
                .odr()
                .modify(|v| {
                    v.set_odr(5, vals::Odr::HIGH);
                });
        }
        /// turn off the LED
        #[allow(dead_code)]
        #[inline]
        pub fn LED_OFF() {
            GPIOA
                .odr()
                .modify(|v| {
                    v.set_odr(5, vals::Odr::LOW);
                });
        }
    }
    /// block delay
    pub mod blockdelay {
        use core::arch::asm;
        /// block delay
        #[inline]
        pub fn delay(time: usize) {
            unsafe {
                asm!(
                    "mov r0, #0\n1:\nmov r1, #0\n2:\nadd r1, r1, #1\ncmp r1, r3\nblt 2b\nadd r0, r0, #1\ncmp r0, r2\nblt 1b",
                    in ("r2") time, in ("r3") 8000000 / 8
                )
            }
        }
    }
}
/// the mod of lang_items
pub mod lang_items {
    use cortex_m_semihosting::debug;
    use panic_probe as _;
    #[export_name = "_defmt_panic"]
    #[inline(never)]
    fn panic() -> ! {
        { cortex_m::asm::udf() }
    }
    /// Terminates the application and makes a semihosting-capable debug tool exit
    /// with status code 0.
    pub fn exit() -> ! {
        loop {
            debug::exit(debug::EXIT_SUCCESS);
        }
    }
    /// Hardfault handler.
    ///
    /// Terminates the application and makes a semihosting-capable debug tool exit
    /// with an error. This seems better than the default, which is to spin in a
    /// loop.
    #[doc(hidden)]
    #[export_name = "HardFault"]
    #[link_section = ".HardFault.user"]
    pub unsafe extern "C" fn __cortex_m_rt_HardFault_trampoline(
        frame: &::cortex_m_rt::ExceptionFrame,
    ) {
        __cortex_m_rt_HardFault(frame)
    }
    /// Hardfault handler.
    ///
    /// Terminates the application and makes a semihosting-capable debug tool exit
    /// with an error. This seems better than the default, which is to spin in a
    /// loop.
    unsafe fn __cortex_m_rt_HardFault(_frame: &cortex_m_rt::ExceptionFrame) -> ! {
        loop {
            debug::exit(debug::EXIT_FAILURE);
        }
    }
}
mod util {
    use core::cell::UnsafeCell;
    use core::mem::MaybeUninit;
    use core::ptr;
    pub(crate) struct UninitCell<T>(MaybeUninit<UnsafeCell<T>>);
    #[allow(unused)]
    impl<T> UninitCell<T> {
        pub const fn uninit() -> Self {
            Self(MaybeUninit::uninit())
        }
        pub unsafe fn as_mut_ptr(&self) -> *mut T {
            (*self.0.as_ptr()).get()
        }
        #[allow(clippy::mut_from_ref)]
        pub unsafe fn as_mut(&self) -> &mut T {
            &mut *self.as_mut_ptr()
        }
        #[inline(never)]
        pub unsafe fn write_in_place(&self, func: impl FnOnce() -> T) {
            ptr::write(self.as_mut_ptr(), func())
        }
        pub unsafe fn drop_in_place(&self) {
            ptr::drop_in_place(self.as_mut_ptr())
        }
    }
    unsafe impl<T> Sync for UninitCell<T> {}
    #[repr(transparent)]
    pub struct SyncUnsafeCell<T> {
        value: UnsafeCell<T>,
    }
    unsafe impl<T: Sync> Sync for SyncUnsafeCell<T> {}
    impl<T: PartialEq> PartialEq for SyncUnsafeCell<T> {
        fn eq(&self, other: &Self) -> bool {
            self.get_unmut() == other.get_unmut()
        }
    }
    impl<T: PartialOrd> PartialOrd for SyncUnsafeCell<T> {
        fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
            self.get_unmut().partial_cmp(other.get_unmut())
        }
    }
    impl<T: Clone> Clone for SyncUnsafeCell<T> {
        fn clone(&self) -> Self {
            Self {
                value: UnsafeCell::new(self.get_unmut().clone()),
            }
        }
    }
    impl<T> SyncUnsafeCell<T> {
        #[inline]
        pub const fn new(value: T) -> Self {
            Self {
                value: UnsafeCell::new(value),
            }
        }
        pub unsafe fn set(&self, value: T) {
            *self.value.get() = value;
        }
        pub unsafe fn get(&self) -> T
        where
            T: Copy,
        {
            *self.value.get()
        }
        pub fn get_mut(&self) -> &mut T {
            unsafe { &mut *self.value.get() }
        }
        pub fn get_unmut(&self) -> &T {
            unsafe { &*self.value.get() }
        }
        /// set and return the old value
        pub unsafe fn swap(&self, value: T) -> T {
            core::mem::replace(&mut *self.value.get(), value)
        }
    }
}
#[cfg(feature = "unstable-pac")]
pub use stm32_metapac as pac;
struct SingleCoreCriticalSection;
#[no_mangle]
unsafe fn _critical_section_1_0_acquire() -> ::critical_section::RawRestoreState {
    <SingleCoreCriticalSection as ::critical_section::Impl>::acquire()
}
#[no_mangle]
unsafe fn _critical_section_1_0_release(
    restore_state: ::critical_section::RawRestoreState,
) {
    <SingleCoreCriticalSection as ::critical_section::Impl>::release(restore_state)
}
unsafe impl Impl for SingleCoreCriticalSection {
    unsafe fn acquire() -> RawRestoreState {
        let was_active = primask::read().is_active();
        interrupt::disable();
        was_active
    }
    unsafe fn release(was_active: RawRestoreState) {
        if was_active {
            interrupt::enable()
        }
    }
}
